<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastTracker Web GUI</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #16213e, #0f3460);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #e94560;
        }
        .header h1 {
            font-size: 20px;
            color: #e94560;
            letter-spacing: 2px;
        }
        .header .status {
            font-size: 13px;
            color: #aaa;
        }

        /* Main layout */
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            padding: 8px;
            height: calc(100vh - 50px);
        }

        /* Panels */
        .panel {
            background: #16213e;
            border-radius: 8px;
            border: 1px solid #333;
            overflow: hidden;
        }
        .panel-header {
            background: #0f3460;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: bold;
            color: #e94560;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Map panel */
        #map-panel {
            grid-row: 1;
            grid-column: 1;
        }
        #map {
            width: 100%;
            height: calc(100% - 32px);
        }

        /* 3D panel */
        #viz-panel {
            grid-row: 1;
            grid-column: 2;
        }
        /* Viz panel tabs */
        .viz-tab-bar {
            display: flex;
            height: 100%;
            align-items: stretch;
        }
        .viz-tab {
            padding: 0 14px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
            white-space: nowrap;
            user-select: none;
            display: flex;
            align-items: center;
        }
        .viz-tab:hover { color: #ccc; background: rgba(233,69,96,0.05); }
        .viz-tab.active { color: #e94560; border-bottom-color: #e94560; background: rgba(233,69,96,0.1); }
        .viz-tab.disabled { color: #444; cursor: not-allowed; }
        .viz-tab.disabled:hover { color: #444; background: none; }
        .viz-tab-content { display: none; width: 100%; height: calc(100% - 32px); }
        .viz-tab-content.active { display: block; }
        #plot3d-trajectory, #plot3d-tracking { width: 100%; height: 100%; }
        #plot-timeline { width: 100%; min-height: 100%; }

        /* Evaluation tab */
        .eval-section-title {
            color: #e94560; font-size: 11px; text-transform: uppercase;
            letter-spacing: 1px; margin: 10px 12px 6px; padding-bottom: 3px;
            border-bottom: 1px solid #333;
        }
        .eval-section-title:first-child { margin-top: 4px; }
        .eval-full-grid {
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 2px 16px; padding: 0 12px;
        }
        .eval-full-item {
            font-size: 11px; padding: 2px 0;
            display: flex; justify-content: space-between; gap: 6px;
        }
        .eval-full-item .label { color: #aaa; white-space: nowrap; cursor: help; }
        .eval-full-item .value { color: #7ec8e3; font-family: monospace; font-weight: bold; text-align: right; }

        /* Tooltip for labels */
        .control-row label[title], .eval-full-item .label[title] {
            cursor: help;
            border-bottom: 1px dotted #555;
        }
        #eval-tab-content { overflow-y: auto; height: 100%; padding: 4px 0; }
        .eval-charts-grid {
            display: flex; flex-direction: column;
            gap: 4px; padding: 4px 8px; margin-top: 4px;
        }
        .eval-chart { height: 200px; background: #0f3460; border-radius: 4px; }
        .eval-placeholder {
            display: flex; align-items: center; justify-content: center;
            height: 100%; color: #555; font-size: 14px;
        }

        /* Control panel */
        #control-panel {
            grid-row: 2;
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .controls-content {
            display: flex;
            gap: 0;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        /* Object list (left sidebar) */
        .object-list {
            display: flex;
            flex-direction: column;
            border-right: 1px solid #333;
            min-width: 110px;
        }
        .object-list-item {
            padding: 10px 14px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: all 0.15s;
        }
        .object-list-item:hover {
            color: #ccc;
            background: rgba(233,69,96,0.05);
        }
        .object-list-item.active {
            color: #e94560;
            border-left-color: #e94560;
            background: rgba(233,69,96,0.1);
        }

        /* Detail pane (right) */
        .detail-pane {
            flex: 1;
            padding: 8px 12px;
            overflow-y: auto;
        }
        .detail-section {
            display: none;
        }
        .detail-section.active {
            display: block;
        }

        /* Control sections */
        .control-section h3 {
            color: #e94560;
            font-size: 12px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            gap: 6px;
            font-size: 11px;
            color: #888;
        }
        .control-row label {
            font-size: 12px;
            min-width: 100px;
            color: #aaa;
        }
        .control-row input, .control-row select {
            background: #0f3460;
            border: 1px solid #444;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            width: 100px;
        }
        .control-row input:focus {
            border-color: #e94560;
            outline: none;
        }
        .lock-label {
            min-width: auto !important;
            margin-left: 2px;
            font-size: 10px !important;
            color: #666 !important;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .lock-label input[type="checkbox"] {
            width: auto;
            min-width: auto;
            padding: 0;
            margin: 0;
        }
        .target-sub-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .coord-display {
            font-size: 11px;
            color: #7ec8e3;
            margin-bottom: 4px;
            font-family: monospace;
        }

        /* Section headers */
        .section-header {
            color: #e94560;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }

        /* Parameter grid layout */
        .param-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        /* Buttons */
        .btn {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
            margin-right: 8px;
        }
        .btn-primary {
            background: #e94560;
            color: white;
        }
        .btn-primary:hover { background: #ff6b81; }
        .btn-primary:disabled { background: #555; cursor: not-allowed; }
        .btn-secondary {
            background: #0f3460;
            color: #7ec8e3;
            border: 1px solid #7ec8e3;
        }
        .btn-secondary:hover { background: #16213e; }
        .btn-secondary:disabled { background: #333; color: #555; border-color: #555; cursor: not-allowed; }

        .button-row {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-top: 1px solid #333;
        }

        /* Evaluation display */
        .eval-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }
        .eval-item {
            font-size: 11px;
            padding: 2px 0;
        }
        .eval-item .label { color: #aaa; }
        .eval-item .value {
            color: #7ec8e3;
            font-family: monospace;
            font-weight: bold;
        }

        /* Loading overlay */
        .loading {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        .loading.active { display: flex; }
        .loading .spinner {
            width: 50px; height: 50px;
            border: 4px solid #333;
            border-top: 4px solid #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading .text {
            margin-top: 16px;
            font-size: 16px;
            color: #e94560;
        }
        .loading .progress-container {
            width: 320px;
            margin-top: 14px;
            display: none;
        }
        .loading .progress-bar-bg {
            background: #333;
            border-radius: 4px;
            height: 8px;
            overflow: hidden;
        }
        .loading .progress-bar-fill {
            height: 100%;
            background: #e94560;
            width: 0%;
            transition: width 0.4s ease;
        }
        .loading .progress-pct {
            font-size: 12px;
            color: #aaa;
            margin-top: 4px;
            text-align: right;
        }
        .loading .progress-detail {
            font-size: 11px;
            color: #888;
            margin-top: 6px;
            text-align: center;
            font-family: monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .loading .btn-cancel {
            margin-top: 16px;
            padding: 6px 20px;
            background: transparent;
            border: 1px solid #e94560;
            color: #e94560;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: none;
        }
        .loading .btn-cancel:hover { background: #e94560; color: #fff; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Map instructions */
        .map-instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div class="header">
    <h1>FASTTRACKER WEB GUI</h1>
    <div class="status" id="status-text">Ready - Click on map to set launch/target points</div>
</div>

<div class="main-container">
    <!-- Map Panel -->
    <div class="panel" id="map-panel">
        <div class="panel-header">
            <span>Map - Launch & Target Selection</span>
            <span id="map-mode-label" style="color: #ff6b81;">Click: Set Launch Point</span>
        </div>
        <div id="map" style="position: relative;">
            <div class="map-instructions" id="map-hint">
                Left: Launch / Right: Target / Middle: Sensor
            </div>
        </div>
    </div>

    <!-- 3D Visualization Panel -->
    <div class="panel" id="viz-panel">
        <div class="panel-header" style="padding: 0;">
            <div class="viz-tab-bar">
                <div class="viz-tab active" data-viz-tab="trajectory" onclick="switchVizTab('trajectory')">Trajectory</div>
                <div class="viz-tab" data-viz-tab="tracking" onclick="switchVizTab('tracking')">Tracking</div>
                <div class="viz-tab" data-viz-tab="evaluation" onclick="switchVizTab('evaluation')">Evaluation</div>
                <div class="viz-tab" data-viz-tab="timeline" onclick="switchVizTab('timeline')">Timeline</div>
                <div class="viz-tab" data-viz-tab="console" onclick="switchVizTab('console')">Console</div>
            </div>
            <span id="viz-info" style="color: #7ec8e3; font-weight: normal; font-size: 11px; padding-right: 10px; white-space: nowrap;"></span>
        </div>
        <div class="viz-tab-content active" id="viz-trajectory">
            <div id="plot3d-trajectory"></div>
        </div>
        <div class="viz-tab-content" id="viz-tracking">
            <div id="plot3d-tracking"></div>
        </div>
        <div class="viz-tab-content" id="viz-evaluation">
            <div id="eval-tab-content">
                <div class="eval-placeholder">Run Tracker to see evaluation metrics</div>
            </div>
        </div>
        <div class="viz-tab-content" id="viz-timeline" style="overflow-y:auto;">
            <div id="plot-timeline" style="width:100%;"></div>
        </div>
        <div class="viz-tab-content" id="viz-console" style="overflow-y:auto; padding:16px;">
            <div id="console-output" style="font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; white-space: pre-wrap; color: #e0e0e0; background: #0a1929; padding: 16px; border-radius: 4px; border: 1px solid #1e3a5f;">
                <div style="color: #7ec8e3; text-align: center; padding: 40px 20px;">Run Tracker to see console output</div>
            </div>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="panel" id="control-panel">
        <div class="panel-header">
            <span>Parameters & Control</span>
        </div>

        <!-- GPU Error Display -->
        <div id="gpu-error-banner" style="display:none; background:#3d1f1f; border-bottom:2px solid #e94560; padding:12px; font-size:11px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <strong style="color:#e94560;">⚠️ GPU Error Detected</strong>
                <button onclick="document.getElementById('gpu-error-banner').style.display='none'" style="background:#e94560; border:none; color:#fff; padding:2px 8px; border-radius:3px; cursor:pointer; font-size:10px;">Close</button>
            </div>
            <pre id="gpu-error-content" style="background:#1a1a2e; padding:8px; border-radius:4px; overflow:auto; max-height:150px; font-size:10px; color:#e0e0e0; font-family:monospace; white-space:pre-wrap; word-wrap:break-word; user-select:text; cursor:text;"></pre>
        </div>

        <div class="controls-content">
            <!-- Object List (left sidebar) -->
            <div class="object-list">
                <div class="object-list-item active" onclick="switchPanel('target')">Target</div>
                <div class="object-list-item" onclick="switchPanel('sensor')">Sensor</div>
                <div class="object-list-item" onclick="switchPanel('tracker')">Tracker</div>
            </div>

            <!-- Detail Pane (right) -->
            <div class="detail-pane">
                <!-- Target -->
                <div class="detail-section active" id="panel-target">
                    <!-- Missile Type -->
                    <div class="section-header">Missile Type</div>
                    <div class="control-row">
                        <label style="min-width:auto;">Type</label>
                        <select id="missile-type" onchange="onMissileTypeChange()" style="background:#0f3460; color:#fff; border:1px solid #e94560; border-radius:4px; padding:4px 8px; font-size:12px; width:140px; font-weight:bold;">
                            <option value="ballistic">Ballistic</option>
                            <option value="hgv">HGV (Hypersonic Glide)</option>
                        </select>
                    </div>

                    <!-- Launch & Impact Locations -->
                    <div class="section-header" style="margin-top: 12px;">Launch & Impact Locations</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Set launch and target impact coordinates using preset locations or map.</div>
                    <div class="coord-display" style="display:flex; align-items:center; gap:4px; flex-wrap:wrap;">
                        <span style="min-width:50px;">Launch:</span>
                        <select id="loc-launch-select" ondblclick="loadLocation('launch')" style="background:#0f3460; color:#fff; border:1px solid #444; border-radius:4px; padding:2px 4px; font-size:11px; flex:1; min-width:80px;"></select>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px;" onclick="loadLocation('launch')">Set</button>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px;" onclick="saveCurrentLocation('launch')">+</button>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px; color:#e94560; border-color:#e94560;" onclick="deleteSelectedLocation('launch')">x</button>
                        <span id="launch-coord" style="font-size:11px; color:#aaa;">Not set</span>
                    </div>
                    <div class="coord-display" style="display:flex; align-items:center; gap:4px; flex-wrap:wrap;">
                        <span style="min-width:50px;">Target:</span>
                        <select id="loc-target-select" ondblclick="loadLocation('target')" style="background:#0f3460; color:#fff; border:1px solid #444; border-radius:4px; padding:2px 4px; font-size:11px; flex:1; min-width:80px;"></select>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px;" onclick="loadLocation('target')">Set</button>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px;" onclick="saveCurrentLocation('target')">+</button>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px; color:#e94560; border-color:#e94560;" onclick="deleteSelectedLocation('target')">x</button>
                        <span id="target-coord" style="font-size:11px; color:#aaa;">Not set</span>
                    </div>
                    <div class="coord-display">
                        Range: <span id="range-display">-</span>
                    </div>

                    <!-- Trajectory Parameters -->
                    <div class="section-header" style="margin-top: 12px;">Trajectory Parameters</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Configure rocket propulsion, aerodynamics, and flight profile.</div>
                    <div class="target-sub-grid">
                        <div>
                            <div class="control-row">
                                <label title="Duration of rocket motor burn [s]. Longer boost increases velocity and range.">Boost Duration</label>
                                <input type="number" id="boost-duration" value="65" min="10" max="200" step="5"> s
                            </div>
                            <div class="control-row">
                                <label title="Acceleration during boost phase [m/s2]. Higher values produce faster missiles.">Boost Accel</label>
                                <input type="number" id="boost-accel" value="30" min="5" max="100" step="5"> m/s2
                            </div>
                            <div class="control-row">
                                <label title="Launch elevation angle [deg]. Steeper angle = higher apogee but shorter range. Auto-adjust optimizes this.">Launch Angle</label>
                                <input type="number" id="launch-angle" value="40" min="15" max="80" step="5"> deg
                                <label class="lock-label" title="Lock: exclude from auto-adjust"><input type="checkbox" id="lock-angle"> Lock</label>
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Total missile mass at launch including fuel [kg].">Initial Mass</label>
                                <input type="number" id="initial-mass" value="20000" min="1000" max="100000" step="1000"> kg
                            </div>
                            <div class="control-row">
                                <label title="Fraction of initial mass that is fuel (0-1). Higher = more fuel = longer burn.">Fuel Fraction</label>
                                <input type="number" id="fuel-fraction" value="0.70" min="0.1" max="0.9" step="0.05">
                                <label class="lock-label" title="Lock: exclude from auto-adjust"><input type="checkbox" id="lock-fuel"> Lock</label>
                            </div>
                            <div class="control-row">
                                <label title="Specific impulse [s]. Engine efficiency metric. Higher Isp = more delta-v per unit fuel.">Isp</label>
                                <input type="number" id="specific-impulse" value="250" min="100" max="500" step="10"> s
                                <label class="lock-label" title="Lock: exclude from auto-adjust"><input type="checkbox" id="lock-isp"> Lock</label>
                            </div>
                            <div class="control-row">
                                <label title="Aerodynamic drag coefficient. Lower = less air resistance. Typical: 0.1-0.5 for missiles.">Drag Coeff (Cd)</label>
                                <input type="number" id="drag-coefficient" value="0.3" min="0.05" max="2.0" step="0.05">
                            </div>
                            <div class="control-row">
                                <label title="Reference cross-sectional area for drag calculation [m2].">Cross Section</label>
                                <input type="number" id="cross-section" value="1.0" min="0.1" max="10.0" step="0.1"> m2
                            </div>
                            <div class="control-row ballistic-only-param">
                                <label title="Target maximum altitude constraint for auto-adjust [km]. 0 = no constraint.">Target Alt</label>
                                <input type="number" id="target-max-altitude" value="0" min="0" max="5000" step="50"> km
                                <span style="font-size:10px; color:#666;">(0=auto)</span>
                            </div>
                            <div class="control-row">
                                <label style="min-width: auto;" title="Automatically adjust launch angle, Isp, and fuel fraction to hit the target position.">
                                    <input type="checkbox" id="auto-adjust" checked> Auto-Adjust
                                </label>
                                <span id="auto-adjust-info" style="font-size:11px; color:#888;"></span>
                            </div>
                            <div class="control-row">
                                <label style="min-width: auto;" title="Simulate booster-warhead separation after boost. Creates two separate tracked objects.">
                                    <input type="checkbox" id="enable-separation" onchange="toggleSeparationParams()"> Separation
                                </label>
                            </div>
                            <div class="control-row" id="sep-params" style="display:none;">
                                <label title="Warhead mass as percentage of dry mass (after fuel is consumed).">Warhead Mass</label>
                                <input type="number" id="warhead-mass-frac" value="30" min="5" max="80" step="5"> %
                            </div>
                        </div>
                    </div>

                    <!-- HGV-Specific Parameters -->
                    <div class="section-header hgv-only-param" style="margin-top: 12px; display:none;">HGV-Specific Parameters</div>
                    <div class="hgv-only-param" style="font-size: 10px; color: #888; margin-bottom: 4px; display:none;">Hypersonic glide vehicle cruise and maneuvering configuration.</div>
                    <div class="param-grid hgv-only-param" style="display:none;">
                        <div>
                            <div class="control-row">
                                <label title="Cruise/glide altitude [km]. HGV glides at this altitude band (30-50km typical).">Cruise Alt</label>
                                <input type="number" id="cruise-altitude" value="40" min="20" max="80" step="5"> km
                            </div>
                            <div class="control-row">
                                <label title="Lift-to-drag ratio (L/D). Higher = more efficient glide. Waverider: 4-6.">Glide Ratio</label>
                                <input type="number" id="glide-ratio" value="4.0" min="2.0" max="8.0" step="0.5">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Distance from target to begin terminal dive [km].">Terminal Dive</label>
                                <input type="number" id="terminal-dive-range" value="20" min="5" max="50" step="5"> km
                            </div>
                            <div class="control-row">
                                <label title="Maximum bank angle during glide [deg]. Controls turn rate.">Max Bank</label>
                                <input type="number" id="bank-angle-max" value="0" min="0" max="80" step="5"> deg
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Number of skip-glide oscillations before terminal dive. 0 = unlimited (distance-based only).">Skips</label>
                                <input type="number" id="num-skips" value="1" min="0" max="20" step="1">
                            </div>
                        </div>
                    </div>

                    <!-- Cluster (Dense Environment) -->
                    <div class="section-header" style="margin-top: 12px;">Cluster (Dense Environment)</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Generate multiple targets with spatial and temporal variation for stress testing.</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="Number of additional targets generated around the main missile. 0 = single target only.">Count</label>
                                <input type="number" id="cluster-count" value="0" min="0" max="20" step="1">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Spatial spread radius [km]. Launch and impact positions of cluster targets are perturbed within this radius.">Spread</label>
                                <input type="number" id="cluster-spread" value="5" min="1" max="50" step="1"> km
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Launch time spread [s]. Each cluster target's launch time is randomly offset within 0 to this value.">Time Spread</label>
                                <input type="number" id="launch-time-spread" value="5" min="0" max="60" step="1"> s
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sensor -->
                <div class="detail-section" id="panel-sensor">
                    <!-- Sensor Position -->
                    <div class="section-header">Sensor Position</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Set radar sensor location using preset or map coordinates.</div>
                    <div class="coord-display" style="display:flex; align-items:center; gap:4px; flex-wrap:wrap;">
                        <span style="min-width:50px;">Position:</span>
                        <select id="loc-sensor-select" ondblclick="loadLocation('sensor')" style="background:#0f3460; color:#fff; border:1px solid #444; border-radius:4px; padding:2px 4px; font-size:11px; flex:1; min-width:80px;"></select>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px;" onclick="loadLocation('sensor')">Set</button>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px;" onclick="saveCurrentLocation('sensor')">+</button>
                        <button class="btn btn-secondary" style="padding:2px 6px; font-size:10px; color:#e94560; border-color:#e94560;" onclick="deleteSelectedLocation('sensor')">x</button>
                        <span id="sensor-coord" style="font-size:11px; color:#aaa;">Not set</span>
                    </div>

                    <!-- Radar Coverage -->
                    <div class="section-header" style="margin-top: 12px;">Radar Coverage</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Define radar surveillance volume and antenna orientation.</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="Minimum radar detection range [km]. Targets closer than this will not be detected.">Min Range</label>
                                <input type="number" id="radar-min-range" value="0" min="0" max="500" step="10"> km
                            </div>
                            <div class="control-row">
                                <label title="Maximum radar detection range [km]. Auto = 1.3x max sensor-target distance.">Max Range</label>
                                <input type="number" id="radar-max-range" value="800" min="10" max="2000" step="10" disabled> km
                                <label class="lock-label" title="Auto: compute from scenario geometry"><input type="checkbox" id="auto-max-range" checked onchange="toggleAutoParam(this, 'radar-max-range')"> Auto</label>
                                <span id="resolved-max-range" style="font-size:10px; color:#4ecdc4;"></span>
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Azimuth coverage width [deg]. 360 = omnidirectional, 120 = sector scan.">Azimuth Coverage</label>
                                <input type="number" id="azimuth-coverage" value="360" min="10" max="360" step="10"> deg
                            </div>
                            <div class="control-row">
                                <label title="Minimum elevation angle [deg]. Physical lower limit (-90 to +90).">Min Elevation</label>
                                <input type="number" id="min-elevation" value="-30" min="-90" max="90" step="5"> deg
                            </div>
                            <div class="control-row">
                                <label title="Maximum elevation angle [deg]. Physical upper limit (-90 to +90).">Max Elevation</label>
                                <input type="number" id="max-elevation" value="90" min="-90" max="90" step="5"> deg
                            </div>
                            <div class="control-row">
                                <label title="Antenna boresight bearing [deg]. 0=North, 90=East. Center of the azimuth coverage.">Ant Bearing</label>
                                <input type="number" id="antenna-bearing" value="0" min="-180" max="360" step="1" disabled onchange="updateSensorCoverage()"> deg
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Auto-compute antenna bearing from sensor-to-launch direction.">Auto Bearing</label>
                                <input type="checkbox" id="auto-antenna-bearing" checked onchange="onAutoAntennaBearingChange()">
                            </div>
                        </div>
                    </div>

                    <!-- Detection Model (Swerling II) -->
                    <div class="section-header" style="margin-top: 12px;">Detection Model (Swerling II)</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Physics-based radar detection with fluctuating RCS and CFAR thresholding.</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="Per-pulse probability of false alarm. Sets CFAR threshold (γ = −ln(Pfa)) and clutter density.">Pfa</label>
                                <input type="text" id="pfa" value="1e-6" style="width:70px;">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Reference range for detection performance [km]. Radar power is set so that P(D) equals the value below at this range.">Ref Range</label>
                                <input type="number" id="pd-ref-range" value="10" min="1" max="5000" step="1"> km
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Detection probability at the reference range. Determines radar transmit power via Swerling II: SNR_avg(R_ref) = −ln(Pfa) / −ln(P(D)).">P(D)@Ref</label>
                                <input type="number" id="pd-ref" value="0.9" min="0.05" max="0.99" step="0.05">
                                <span id="resolved-snr-ref" style="font-size:10px; color:#4ecdc4;"></span>
                            </div>
                        </div>
                    </div>

                    <!-- Measurement Noise (1σ) -->
                    <div class="section-header" style="margin-top: 12px;">Measurement Noise (1σ)</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Sensor measurement accuracy (Gaussian noise standard deviations).</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="Range measurement noise 1-sigma [m]. Radar range resolution.">Range</label>
                                <input type="number" id="range-noise" value="10" min="1" max="500" step="1"> m
                            </div>
                            <div class="control-row">
                                <label title="Azimuth angle measurement noise 1-sigma [deg]. Cross-range error = range x azimuth_noise_rad.">Azimuth</label>
                                <input type="number" id="azimuth-noise" value="0.57" min="0.01" max="6" step="0.01"> deg
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Elevation angle measurement noise 1-sigma [deg]. Altitude estimation accuracy.">Elevation</label>
                                <input type="number" id="elevation-noise" value="0.57" min="0.01" max="6" step="0.01"> deg
                            </div>
                            <div class="control-row">
                                <label title="Doppler velocity measurement noise 1-sigma [m/s]. Radial velocity accuracy.">Doppler</label>
                                <input type="number" id="doppler-noise" value="2" min="0.1" max="20" step="0.5"> m/s
                            </div>
                        </div>
                    </div>

                    <!-- Beam Steering -->
                    <div class="section-header" style="margin-top: 12px;">Beam Steering</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Phased array beam scheduling: track beams follow confirmed targets, search beams raster-scan for new detections.</div>
                    <div class="param-grid"  style="grid-template-columns: repeat(2, 1fr);">
                        <div>
                            <div class="control-row">
                                <label title="Angular width of each radar beam [degrees]. Typical phased array: 1-5 degrees.">Beam Width</label>
                                <input type="number" id="beam-width" value="3" min="0.5" max="30" step="0.5"> deg
                            </div>
                            <div class="control-row">
                                <label title="Number of beam dwells per frame. Budget split between track beams (pointing at known targets) and search beams (raster scan for new targets).">Beams/Frame</label>
                                <input type="number" id="num-beams" value="10" min="1" max="50" step="1" onchange="validateBeamAllocation()">
                            </div>
                            <div class="control-row">
                                <label title="Minimum number of beams reserved for search (raster scan). Higher values ensure faster new target discovery but reduce tracking capacity.">Min Search</label>
                                <input type="number" id="min-search-beams" value="1" min="1" max="20" step="1" onchange="validateBeamAllocation()">
                            </div>
                            <div id="beam-warning" style="display:none; background-color: #fff3cd; border: 3px solid #ff9800; color: #856404; padding: 10px; margin: 8px 0; border-radius: 6px; font-size: 11px; font-weight: 500;">
                                <div style="font-size: 13px; font-weight: bold; margin-bottom: 4px;">⚠️ WARNING: No track beams available!</div>
                                <div style="margin: 4px 0;">Num Beams (<span id="warn-num-beams" style="font-weight: bold;"></span>) ≤ Min Search (<span id="warn-min-search" style="font-weight: bold;"></span>)</div>
                                <div style="margin: 4px 0; font-weight: bold; color: #d84315;">→ Tracks will NOT receive beam allocation!</div>
                                <div style="margin-top: 6px; font-style: italic; color: #5d4037;">Fix: Increase Beams/Frame OR decrease Min Search</div>
                            </div>
                            <div class="control-row">
                                <label title="Track beam priority. 'All' assigns beams to both confirmed and tentative tracks. 'Confirmed' only assigns to confirmed tracks.">Track Priority</label>
                                <select id="track-priority">
                                    <option value="all" selected>All Tracks</option>
                                    <option value="confirmed">Confirmed Only</option>
                                </select>
                            </div>
                            <div class="control-row">
                                <label title="Auto-calculate search sector, center, and elevation from launch/target/sensor geometry.">Auto Sector</label>
                                <input type="checkbox" id="auto-search-sector" checked onchange="onAutoSearchSectorChange()">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Angular width of the search scan sector [degrees]. Search beams raster-scan within this sector. 0 = use full FOV.">Search Sector</label>
                                <input type="number" id="search-sector" value="0" min="0" max="360" step="1" disabled onchange="updateSensorCoverage()"> deg
                            </div>
                            <div class="control-row">
                                <label title="Center offset of the search sector from boresight (North) [degrees]. Positive = clockwise.">Search Center</label>
                                <input type="number" id="search-center" value="0" min="-180" max="180" step="1" disabled onchange="updateSensorCoverage()"> deg
                            </div>
                            <div class="control-row">
                                <label title="Search beam elevation angle [degrees above horizon]. Beams scan in azimuth at this fixed elevation.">Search Elev</label>
                                <input type="number" id="search-elevation" value="0" min="-90" max="90" step="0.5" disabled> deg
                            </div>
                            <div class="control-row">
                                <label title="Minimum range for search coverage [km]. Search beams focus on targets beyond this range.">Search Min Range</label>
                                <input type="number" id="search-min-range" value="0" min="0" max="1000" step="10"> km
                            </div>
                            <div class="control-row">
                                <label title="Maximum range for search coverage [km]. Search beams focus on targets within this range. 0 = use radar max range.">Search Max Range</label>
                                <input type="number" id="search-max-range" value="0" min="0" max="2000" step="10"> km
                            </div>
                            <div class="control-row">
                                <label title="Track beam range gate width [km]. Range window centered on each target's position (±width/2). 0 = no range gating (use full radar range).">Track Range Width</label>
                                <input type="number" id="track-range-width" value="0" min="0" max="500" step="10"> km
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tracker -->
                <div class="detail-section" id="panel-tracker">
                    <!-- Track Management -->
                    <div class="section-header">Track Management</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="Simulation time step [s]. Smaller = more accurate but slower. Defines tracker update rate.">Time Step</label>
                                <input type="number" id="time-step" value="0.5" min="0.1" max="2.0" step="0.1"> s
                            </div>
                            <div class="control-row">
                                <label title="Mahalanobis distance gate for data association. HGV: 30, Ballistic: 15. Higher = more tolerant to maneuvers.">Gate Threshold</label>
                                <input type="number" id="gate-threshold" value="30" min="1" max="100" step="1">
                            </div>
                            <div class="control-row">
                                <label title="Maximum distance [m] for data association. Measurements beyond this are rejected regardless of gate.">Max Distance</label>
                                <input type="number" id="max-distance" value="100000" min="1000" max="500000" step="1000"> m
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Number of consecutive hits required to confirm a tentative track. Lower = faster confirmation but more false tracks.">Confirm Hits</label>
                                <input type="number" id="confirm-hits" value="3" min="1" max="15" step="1">
                            </div>
                            <div class="control-row">
                                <label title="Number of consecutive misses before a track is deleted. HGV: 20, Ballistic: 8. Higher = more robust to maneuvers.">Delete Misses</label>
                                <input type="number" id="delete-misses" value="20" min="1" max="200" step="1">
                            </div>
                            <div class="control-row">
                                <label title="Minimum SNR [dB] to initiate a new track. Higher = fewer false tracks from clutter.">Min SNR</label>
                                <input type="number" id="min-snr" value="10" min="-40" max="60" step="1"> dB
                            </div>
                        </div>
                    </div>

                    <!-- Process Noise -->
                    <div class="section-header" style="margin-top: 12px;">Process Noise</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Models uncertainties in target dynamics. Higher noise = filter trusts measurements more.</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="Process noise for position [m]. Models unmodeled position disturbances. Higher = filter trusts measurements more.">Position</label>
                                <input type="number" id="process-pos-noise" value="300" min="0.1" max="500" step="5"> m
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Process noise for velocity [m/s]. Models unmodeled velocity changes. Higher = faster adaptation to maneuvers.">Velocity</label>
                                <input type="number" id="process-vel-noise" value="150" min="0.1" max="200" step="5"> m/s
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Process noise for acceleration [m/s2]. Models unmodeled acceleration (maneuvers). Higher = more responsive to sudden changes.">Acceleration</label>
                                <input type="number" id="process-acc-noise" value="300" min="0.1" max="500" step="5"> m/s²
                            </div>
                        </div>
                    </div>

                    <!-- UKF Parameters -->
                    <div class="section-header" style="margin-top: 12px;">UKF Parameters</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Unscented Kalman Filter tuning parameters. Default values work well for most cases.</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="UKF scaling parameter alpha. Controls sigma point spread. Typical: 0.001-1.0. Smaller = more conservative.">Alpha</label>
                                <input type="number" id="ukf-alpha" value="0.5" min="0.001" max="1.0" step="0.01">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="UKF distribution shape parameter beta. Optimal for Gaussian: 2.0. Incorporates prior knowledge of distribution.">Beta</label>
                                <input type="number" id="ukf-beta" value="2.0" min="0" max="4" step="0.1">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="UKF secondary scaling parameter kappa. Typical: 0 or 3-n where n=state dimension. 0 = standard choice.">Kappa</label>
                                <input type="number" id="ukf-kappa" value="0.0" min="-10" max="10" step="0.5">
                            </div>
                        </div>
                    </div>

                    <!-- IMM Transition Matrix -->
                    <div class="section-header" style="margin-top: 12px;">IMM Transition Probabilities</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">From → To: CV=Constant Velocity, Bal=Ballistic, CT=Coordinated Turn. Each row sums to 1.0.</div>
                    <div class="param-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div>
                            <div class="control-row">
                                <label title="CV→CV: Probability of staying in Constant Velocity model">CV→CV</label>
                                <input type="number" id="imm-cv-cv" value="0.80" min="0.01" max="0.99" step="0.01">
                            </div>
                            <div class="control-row">
                                <label title="CV→Bal: Probability of transitioning from CV to Ballistic">CV→Bal</label>
                                <input type="number" id="imm-cv-bal" value="0.15" min="0.01" max="0.99" step="0.01">
                            </div>
                            <div class="control-row">
                                <label title="CV→CT: Probability of transitioning from CV to Coordinated Turn">CV→CT</label>
                                <input type="number" id="imm-cv-ct" value="0.05" min="0.01" max="0.99" step="0.01">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Bal→CV: Probability of transitioning from Ballistic to CV">Bal→CV</label>
                                <input type="number" id="imm-bal-cv" value="0.10" min="0.01" max="0.99" step="0.01">
                            </div>
                            <div class="control-row">
                                <label title="Bal→Bal: Probability of staying in Ballistic model">Bal→Bal</label>
                                <input type="number" id="imm-bal-bal" value="0.85" min="0.01" max="0.99" step="0.01">
                            </div>
                            <div class="control-row">
                                <label title="Bal→CT: Probability of transitioning from Ballistic to Coordinated Turn">Bal→CT</label>
                                <input type="number" id="imm-bal-ct" value="0.05" min="0.01" max="0.99" step="0.01">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="CT→CV: Probability of transitioning from Coordinated Turn to CV">CT→CV</label>
                                <input type="number" id="imm-ct-cv" value="0.05" min="0.01" max="0.99" step="0.01">
                            </div>
                            <div class="control-row">
                                <label title="CT→Bal: Probability of transitioning from Coordinated Turn to Ballistic">CT→Bal</label>
                                <input type="number" id="imm-ct-bal" value="0.10" min="0.01" max="0.99" step="0.01">
                            </div>
                            <div class="control-row">
                                <label title="CT→CT: Probability of staying in Coordinated Turn model">CT→CT</label>
                                <input type="number" id="imm-ct-ct" value="0.85" min="0.01" max="0.99" step="0.01">
                            </div>
                        </div>
                    </div>

                    <!-- IMM Model Process Noise -->
                    <div class="section-header" style="margin-top: 12px;">IMM Model Process Noise Multipliers</div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 4px;">Multipliers applied to base process noise for each model. Lower = model trusts physics more, higher = more adaptive.</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="CV (Constant Velocity) process noise multiplier. Lower = assumes steady flight, higher = handles acceleration better.">CV Noise</label>
                                <input type="number" id="imm-cv-noise" value="0.1" min="0.01" max="2.0" step="0.05">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Ballistic process noise multiplier. Physics model is accurate, so keep low. Higher = compensates for atmospheric variations.">Bal Noise</label>
                                <input type="number" id="imm-bal-noise" value="0.3" min="0.01" max="2.0" step="0.05">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="CT (Coordinated Turn) process noise multiplier. Higher = tracks aggressive maneuvers better but may follow noise.">CT Noise</label>
                                <input type="number" id="imm-ct-noise" value="1.0" min="0.01" max="2.0" step="0.05">
                            </div>
                        </div>
                    </div>

                    <!-- Simulation Settings -->
                    <div class="section-header" style="margin-top: 12px;">Simulation Settings</div>
                    <div class="param-grid">
                        <div>
                            <div class="control-row">
                                <label title="Number of Monte Carlo simulation runs. Multiple runs provide mean +/- std statistics for robust evaluation.">Num Runs</label>
                                <input type="number" id="num-runs" value="10" min="1" max="100" step="1">
                            </div>
                        </div>
                        <div>
                            <div class="control-row">
                                <label title="Random seed for reproducibility. 0 = random (different each time). >0 = deterministic (same seed = same result).">Seed</label>
                                <input type="number" id="random-seed" value="0" min="0" max="999999" step="1">
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <div style="color: #e94560; font-size: 12px; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 1px;">Evaluation Results</div>
                        <div class="eval-grid" id="eval-results">
                            <div class="eval-item"><span class="label">Status:</span> <span class="value">Waiting</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="button-row">
            <button class="btn btn-primary" id="btn-generate" onclick="generateTrajectory()">
                Generate Trajectory
            </button>
            <button class="btn btn-secondary" id="btn-run-tracker" onclick="runTracker()" disabled>
                Run Tracker
            </button>
            <button class="btn btn-secondary" onclick="clearAll()">
                Clear
            </button>
            <span style="border-left: 1px solid #444; height: 24px; margin: 0 8px;"></span>
            <button class="btn btn-secondary" onclick="saveScenario()">
                Save Scenario
            </button>
            <button class="btn btn-secondary" onclick="document.getElementById('load-file').click()">
                Load Scenario
            </button>
            <input type="file" id="load-file" accept=".json" style="display:none;" onchange="loadScenario(event)">
            <span id="progress-text" style="font-size: 12px; color: #aaa; margin-left: 12px;"></span>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div class="loading" id="loading">
    <div class="spinner" id="loading-spinner"></div>
    <div class="text" id="loading-text">Generating trajectory...</div>
    <div class="progress-container" id="loading-progress-container">
        <div class="progress-bar-bg">
            <div class="progress-bar-fill" id="loading-progress-bar"></div>
        </div>
        <div class="progress-pct" id="loading-progress-pct">0%</div>
        <div class="progress-detail" id="loading-progress-detail"></div>
    </div>
    <button class="btn-cancel" id="btn-cancel-tracker" onclick="cancelTracker()">Cancel</button>
</div>

<script>
// ========================================
// State
// ========================================
let launchPoint = null;
let targetPoint = null;
let sensorPoint = null;
let launchMarker = null;
let targetMarker = null;
let sensorMarker = null;
let sensorCoverageCircle = null;
let sensorFovPolygon = null;
let searchSectorPolygon = null;
let trajectoryLine = null;
let currentTrajectory = null;

// ========================================
// Map Initialization
// ========================================
const map = L.map('map').setView([35, 130], 4);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors',
    maxZoom: 18,
}).addTo(map);

// Custom icons
const launchIcon = L.divIcon({
    html: '<div style="background:#e94560; width:16px; height:16px; border-radius:50%; border:3px solid #fff; box-shadow:0 0 10px #e94560;"></div>',
    iconSize: [16, 16],
    iconAnchor: [8, 8],
    className: '',
});
const targetIcon = L.divIcon({
    html: '<div style="background:#7ec8e3; width:16px; height:16px; border-radius:0; border:3px solid #fff; transform:rotate(45deg); box-shadow:0 0 10px #7ec8e3;"></div>',
    iconSize: [16, 16],
    iconAnchor: [8, 8],
    className: '',
});

// Left click = launch point
map.on('click', function(e) {
    setLaunchPoint(e.latlng.lat, e.latlng.lng);
});

// Right click = target point
map.on('contextmenu', function(e) {
    e.originalEvent.preventDefault();
    setTargetPoint(e.latlng.lat, e.latlng.lng);
});

// Middle click = sensor point
map.getContainer().addEventListener('mousedown', function(e) {
    if (e.button === 1) {
        e.preventDefault();
        const point = map.mouseEventToLatLng(e);
        setSensorPoint(point.lat, point.lng);
    }
});

function setLaunchPoint(lat, lon) {
    launchPoint = { lat, lon };
    if (launchMarker) map.removeLayer(launchMarker);
    launchMarker = L.marker([lat, lon], { icon: launchIcon })
        .addTo(map)
        .bindPopup(`Launch: ${lat.toFixed(4)}, ${lon.toFixed(4)}`);
    document.getElementById('launch-coord').textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    updateRange();
    autoComputeAntennaBearing();
    autoComputeSearchSector();
    autoComputeSearchElevation();
    autoComputePdRefRange();
    updateSensorCoverage();
}

function setTargetPoint(lat, lon) {
    targetPoint = { lat, lon };
    if (targetMarker) map.removeLayer(targetMarker);
    targetMarker = L.marker([lat, lon], { icon: targetIcon })
        .addTo(map)
        .bindPopup(`Target: ${lat.toFixed(4)}, ${lon.toFixed(4)}`);
    document.getElementById('target-coord').textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    updateRange();
    autoComputeAntennaBearing();
    autoComputeSearchSector();
    autoComputeSearchElevation();
    autoComputePdRefRange();
}

function updateRange() {
    if (launchPoint && targetPoint) {
        const R = 6371;
        const dLat = (targetPoint.lat - launchPoint.lat) * Math.PI / 180;
        const dLon = (targetPoint.lon - launchPoint.lon) * Math.PI / 180;
        const a = Math.sin(dLat/2)**2 + Math.cos(launchPoint.lat * Math.PI/180) * Math.cos(targetPoint.lat * Math.PI/180) * Math.sin(dLon/2)**2;
        const d = 2 * R * Math.asin(Math.sqrt(a));
        document.getElementById('range-display').textContent = `${d.toFixed(0)} km`;

        // Draw line on map
        if (trajectoryLine) map.removeLayer(trajectoryLine);
        trajectoryLine = L.polyline(
            [[launchPoint.lat, launchPoint.lon], [targetPoint.lat, targetPoint.lon]],
            { color: '#e94560', dashArray: '10,10', weight: 2, opacity: 0.7 }
        ).addTo(map);
    }
}

function setSensorPoint(lat, lon) {
    sensorPoint = { lat, lon };
    document.getElementById('sensor-coord').textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    updateSensorMarker();
    autoComputeAntennaBearing();
    autoComputeSearchSector();
    autoComputeSearchElevation();
    autoComputePdRefRange();
    updateSensorCoverage();
}

function getSensorLatLng() {
    if (sensorPoint) return sensorPoint;
    if (targetPoint) return targetPoint;
    return null;
}

function updateSensorMarker() {
    const pos = getSensorLatLng();
    if (!pos) return;

    if (sensorMarker) map.removeLayer(sensorMarker);
    const isFallback = !sensorPoint;
    const sensorIcon = L.divIcon({
        html: `<div style="width:0;height:0;border-left:9px solid transparent;border-right:9px solid transparent;border-bottom:18px solid ${isFallback ? '#32ff3280' : '#32ff32'};filter:drop-shadow(0 0 6px #32ff32);"></div>`,
        iconSize: [18, 18],
        iconAnchor: [9, 18],
        className: '',
    });
    sensorMarker = L.marker([pos.lat, pos.lon], { icon: sensorIcon })
        .addTo(map)
        .bindPopup(`Sensor: ${pos.lat.toFixed(4)}, ${pos.lon.toFixed(4)}${isFallback ? ' (=Target)' : ''}`);
    if (isFallback) {
        document.getElementById('sensor-coord').textContent = 'Not set (=Target)';
        document.getElementById('sensor-coord').style.color = '#666';
    } else {
        document.getElementById('sensor-coord').style.color = '#aaa';
    }
}

function updateSensorCoverage() {
    // Remove old coverage
    if (sensorCoverageCircle) map.removeLayer(sensorCoverageCircle);
    if (sensorFovPolygon) map.removeLayer(sensorFovPolygon);
    if (searchSectorPolygon) map.removeLayer(searchSectorPolygon);
    sensorCoverageCircle = null;
    sensorFovPolygon = null;
    searchSectorPolygon = null;

    const pos = getSensorLatLng();
    if (!pos) return;

    // Get max range in meters
    const autoRange = document.getElementById('auto-max-range').checked;
    let maxRangeKm = autoRange ? 0 : parseFloat(document.getElementById('radar-max-range').value);
    if (maxRangeKm <= 0 && launchPoint && targetPoint) {
        // Auto: estimate from launch-target range
        const R = 6371;
        const dLat = (launchPoint.lat - targetPoint.lat) * Math.PI / 180;
        const dLon = (launchPoint.lon - targetPoint.lon) * Math.PI / 180;
        const a = Math.sin(dLat/2)**2 + Math.cos(launchPoint.lat * Math.PI/180) * Math.cos(targetPoint.lat * Math.PI/180) * Math.sin(dLon/2)**2;
        const d = 2 * R * Math.asin(Math.sqrt(a));
        maxRangeKm = d * 1.3;
    }
    if (maxRangeKm <= 0) return;

    const maxRangeM = maxRangeKm * 1000;
    const fovDeg = parseFloat(document.getElementById('azimuth-coverage').value) || 360;

    // Helper: draw a wedge polygon from sensor at given angular range
    function makeWedge(startDeg, endDeg, range) {
        const numPoints = 60;
        const pts = [[pos.lat, pos.lon]];
        const spanDeg = endDeg - startDeg;
        for (let i = 0; i <= numPoints; i++) {
            const angle = (startDeg + spanDeg * i / numPoints) * Math.PI / 180;
            const lat2 = pos.lat + (range / 111320) * Math.cos(angle);
            const lon2 = pos.lon + (range / (111320 * Math.cos(pos.lat * Math.PI / 180))) * Math.sin(angle);
            pts.push([lat2, lon2]);
        }
        pts.push([pos.lat, pos.lon]);
        return pts;
    }

    if (fovDeg >= 360) {
        // Full circle
        sensorCoverageCircle = L.circle([pos.lat, pos.lon], {
            radius: maxRangeM,
            color: '#32ff32',
            fillColor: '#32ff32',
            fillOpacity: 0.08,
            weight: 1.5,
            opacity: 0.6,
            dashArray: '6,4',
        }).addTo(map);
    } else {
        // Draw FOV wedge centered on antenna bearing
        const antBearing = parseFloat(document.getElementById('antenna-bearing').value) || 0;
        const halfFov = fovDeg / 2;
        const fovPoints = makeWedge(antBearing - halfFov, antBearing + halfFov, maxRangeM);
        sensorFovPolygon = L.polygon(fovPoints, {
            color: '#32ff32',
            fillColor: '#32ff32',
            fillOpacity: 0.06,
            weight: 1.5,
            opacity: 0.6,
            dashArray: '6,4',
        }).addTo(map);
    }

    // Draw integrated search coverage (sector + range)
    const searchSectorDeg = parseFloat(document.getElementById('search-sector').value) || 0;
    const searchCenterDeg = parseFloat(document.getElementById('search-center').value) || 0;
    const searchMinKm = parseFloat(document.getElementById('search-min-range').value) || 0;
    const searchMaxKm = parseFloat(document.getElementById('search-max-range').value) || 0;

    // Determine effective search range
    const searchMinM = searchMinKm * 1000;
    const searchMaxM = (searchMaxKm > 0 && searchMaxKm < maxRangeKm) ? searchMaxKm * 1000 : maxRangeM;

    // Draw search coverage area
    if (searchSectorDeg > 0 || searchMinKm > 0 || (searchMaxKm > 0 && searchMaxKm < maxRangeKm)) {
        const sMin = searchCenterDeg - searchSectorDeg / 2;
        const sMax = searchCenterDeg + searchSectorDeg / 2;

        // Use full FOV if no specific search sector is set
        const azMin = searchSectorDeg > 0 ? sMin : (parseFloat(document.getElementById('antenna-bearing').value) || 0) - fovDeg / 2;
        const azMax = searchSectorDeg > 0 ? sMax : (parseFloat(document.getElementById('antenna-bearing').value) || 0) + fovDeg / 2;

        // Create annulus (ring) or full wedge
        const numPoints = 60;
        const pts = [];

        // Outer arc (max range)
        for (let i = 0; i <= numPoints; i++) {
            const angle = (azMin + (azMax - azMin) * i / numPoints) * Math.PI / 180;
            const lat = pos.lat + (searchMaxM / 111320) * Math.cos(angle);
            const lon = pos.lon + (searchMaxM / (111320 * Math.cos(pos.lat * Math.PI / 180))) * Math.sin(angle);
            pts.push([lat, lon]);
        }

        // Inner arc (min range) - reverse direction
        if (searchMinM > 0) {
            for (let i = numPoints; i >= 0; i--) {
                const angle = (azMin + (azMax - azMin) * i / numPoints) * Math.PI / 180;
                const lat = pos.lat + (searchMinM / 111320) * Math.cos(angle);
                const lon = pos.lon + (searchMinM / (111320 * Math.cos(pos.lat * Math.PI / 180))) * Math.sin(angle);
                pts.push([lat, lon]);
            }
        } else {
            // No inner arc - close at center
            pts.push([pos.lat, pos.lon]);
        }

        searchSectorPolygon = L.polygon(pts, {
            color: '#4fc3f7',
            fillColor: '#4fc3f7',
            fillOpacity: 0.15,
            weight: 2,
            opacity: 0.8,
        }).addTo(map);
    }
}

// Auto search sector calculation
function computeBearing(lat1, lon1, lat2, lon2) {
    // Returns bearing in degrees, 0=North, positive=clockwise
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const lat1r = lat1 * Math.PI / 180;
    const lat2r = lat2 * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(lat2r);
    const x = Math.cos(lat1r) * Math.sin(lat2r) - Math.sin(lat1r) * Math.cos(lat2r) * Math.cos(dLon);
    return Math.atan2(y, x) * 180 / Math.PI;
}

function autoComputeSearchSector() {
    if (!document.getElementById('auto-search-sector').checked) return;
    const sensor = getSensorLatLng();
    if (!sensor || !launchPoint) {
        document.getElementById('search-sector').value = 0;
        document.getElementById('search-center').value = 0;
        updateSensorCoverage();
        return;
    }

    const fovDeg = parseFloat(document.getElementById('azimuth-coverage').value) || 360;

    // Bearing from sensor to launch point (threat origin)
    const bearingToLaunch = computeBearing(sensor.lat, sensor.lon, launchPoint.lat, launchPoint.lon);

    // Bearing from sensor to target point (defended asset)
    // Skip if sensor ≈ target (fallback case: distance < 1km)
    let bearingToTarget = bearingToLaunch;
    if (targetPoint) {
        const dLat = Math.abs(sensor.lat - targetPoint.lat);
        const dLon = Math.abs(sensor.lon - targetPoint.lon);
        if (dLat > 0.01 || dLon > 0.01) {
            bearingToTarget = computeBearing(sensor.lat, sensor.lon, targetPoint.lat, targetPoint.lon);
        }
    }

    // Angular span between launch and target bearings
    let span = bearingToTarget - bearingToLaunch;
    // Normalize to [-180, 180]
    while (span > 180) span -= 360;
    while (span < -180) span += 360;

    // Center bearing (midpoint of the two bearings)
    let center = bearingToLaunch + span / 2;
    // Normalize to [-180, 180]
    while (center > 180) center -= 360;
    while (center < -180) center += 360;

    // Sector width = angular span + margin (20° each side), minimum 30°
    const margin = 20;
    let sector = Math.abs(span) + margin * 2;
    sector = Math.max(sector, 30);
    sector = Math.min(sector, fovDeg); // don't exceed FOV

    document.getElementById('search-sector').value = Math.round(sector);
    document.getElementById('search-center').value = Math.round(center);
    updateSensorCoverage();
}

function onAutoSearchSectorChange() {
    const auto = document.getElementById('auto-search-sector').checked;
    ['search-sector', 'search-center', 'search-elevation', 'pd-ref-range'].forEach(id => {
        const el = document.getElementById(id);
        el.disabled = auto;
        el.style.opacity = auto ? '0.4' : '1';
    });
    if (auto) {
        autoComputeSearchSector();
        autoComputeSearchElevation();
        autoComputePdRefRange();
    }
}

// Auto antenna bearing calculation
function autoComputeAntennaBearing() {
    if (!document.getElementById('auto-antenna-bearing').checked) return;
    const sensor = getSensorLatLng();
    if (!sensor || !launchPoint) {
        document.getElementById('antenna-bearing').value = 0;
        updateSensorCoverage();
        return;
    }

    // Point antenna midway between launch and target directions
    const bearingToLaunch = computeBearing(sensor.lat, sensor.lon, launchPoint.lat, launchPoint.lon);
    let bearingToTarget = bearingToLaunch;
    if (targetPoint) {
        const dLat = Math.abs(sensor.lat - targetPoint.lat);
        const dLon = Math.abs(sensor.lon - targetPoint.lon);
        if (dLat > 0.01 || dLon > 0.01) {
            bearingToTarget = computeBearing(sensor.lat, sensor.lon, targetPoint.lat, targetPoint.lon);
        }
    }
    let span = bearingToTarget - bearingToLaunch;
    while (span > 180) span -= 360;
    while (span < -180) span += 360;
    let center = bearingToLaunch + span / 2;
    while (center > 180) center -= 360;
    while (center < -180) center += 360;

    document.getElementById('antenna-bearing').value = Math.round(center);
    updateSensorCoverage();
}

function onAutoAntennaBearingChange() {
    const auto = document.getElementById('auto-antenna-bearing').checked;
    const el = document.getElementById('antenna-bearing');
    el.disabled = auto;
    el.style.opacity = auto ? '0.4' : '1';
    if (auto) {
        autoComputeAntennaBearing();
    }
}

// Beam allocation validation
function validateBeamAllocation() {
    const numBeams = parseInt(document.getElementById('num-beams').value) || 0;
    const minSearch = parseInt(document.getElementById('min-search-beams').value) || 0;
    const warningDiv = document.getElementById('beam-warning');

    if (numBeams <= minSearch) {
        // Show warning
        document.getElementById('warn-num-beams').textContent = numBeams;
        document.getElementById('warn-min-search').textContent = minSearch;
        warningDiv.style.display = 'block';
    } else {
        // Hide warning
        warningDiv.style.display = 'none';
    }
}

// Auto search elevation calculation
function autoComputeSearchElevation() {
    if (!document.getElementById('auto-search-sector').checked) return;
    const sensor = getSensorLatLng();

    // Fallback: compute from currentTrajectory when map points are not set
    if (!sensor || !launchPoint) {
        if (currentTrajectory && currentTrajectory.trajectory && currentTrajectory.trajectory.length > 0) {
            const traj = currentTrajectory.trajectory;
            // Sensor position in km (default origin if no map sensor set)
            const snx = sensor ? 0 : 0;  // lat/lon sensor → converted at C++ level; use 0,0 here
            const sny = 0;
            let minElevDeg = 90;
            for (let ti = 0; ti < traj.length; ti++) {
                const pt = traj[ti];
                const px = (parseFloat(pt.x) || 0) / 1000;   // m → km
                const py = (parseFloat(pt.y) || 0) / 1000;
                const alt = (parseFloat(pt.altitude) || 0) / 1000;  // m → km
                const horiz = Math.sqrt((px - snx) * (px - snx) + (py - sny) * (py - sny));
                if (alt <= 0 || horiz <= 0) continue;
                const elDeg = Math.atan2(alt, horiz) * 180 / Math.PI;
                if (elDeg < minElevDeg) minElevDeg = elDeg;
            }
            document.getElementById('search-elevation').value =
                Math.round(Math.max(0, minElevDeg < 90 ? minElevDeg : 0) * 2) / 2;
        } else {
            document.getElementById('search-elevation').value = 0;
        }
        return;
    }

    const R = 6371;
    // Haversine distance sensor→launch [km]
    const dLat = (launchPoint.lat - sensor.lat) * Math.PI / 180;
    const dLon = (launchPoint.lon - sensor.lon) * Math.PI / 180;
    const a = Math.sin(dLat/2)**2 + Math.cos(sensor.lat * Math.PI/180) * Math.cos(launchPoint.lat * Math.PI/180) * Math.sin(dLon/2)**2;
    const distToLaunchKm = 2 * R * Math.asin(Math.sqrt(a));

    let distToTargetKm = distToLaunchKm;
    if (targetPoint) {
        const dLat2 = (targetPoint.lat - sensor.lat) * Math.PI / 180;
        const dLon2 = (targetPoint.lon - sensor.lon) * Math.PI / 180;
        const a2 = Math.sin(dLat2/2)**2 + Math.cos(sensor.lat * Math.PI/180) * Math.cos(targetPoint.lat * Math.PI/180) * Math.sin(dLon2/2)**2;
        distToTargetKm = 2 * R * Math.asin(Math.sqrt(a2));
    }

    let totalRangeKm = distToLaunchKm;
    if (targetPoint) {
        const dLat3 = (targetPoint.lat - launchPoint.lat) * Math.PI / 180;
        const dLon3 = (targetPoint.lon - launchPoint.lon) * Math.PI / 180;
        const a3 = Math.sin(dLat3/2)**2 + Math.cos(launchPoint.lat * Math.PI/180) * Math.cos(targetPoint.lat * Math.PI/180) * Math.sin(dLon3/2)**2;
        totalRangeKm = 2 * R * Math.asin(Math.sqrt(a3));
    }

    const launchAngleDeg = parseFloat(document.getElementById('launch-angle').value) || 45;
    const maxAltKm = totalRangeKm * Math.tan(launchAngleDeg * Math.PI / 180) / 4;

    // Project launch/target to sensor-relative Cartesian [km]
    const brgLaunch = computeBearing(sensor.lat, sensor.lon, launchPoint.lat, launchPoint.lon) * Math.PI / 180;
    const lx = distToLaunchKm * Math.sin(brgLaunch);
    const ly = distToLaunchKm * Math.cos(brgLaunch);
    const brgTarget = targetPoint
        ? computeBearing(sensor.lat, sensor.lon, targetPoint.lat, targetPoint.lon) * Math.PI / 180
        : brgLaunch;
    const tx = distToTargetKm * Math.sin(brgTarget);
    const ty = distToTargetKm * Math.cos(brgTarget);

    // Scan trajectory points; find minimum elevation angle (= earliest detectable)
    let minElevDeg = 90;
    const N = 40;
    for (let fi = 1; fi < N; fi++) {
        const f = fi / N;
        const px = lx + f * (tx - lx);
        const py = ly + f * (ty - ly);
        const horiz = Math.sqrt(px * px + py * py);
        const alt = 4 * maxAltKm * f * (1 - f);
        if (alt <= 0 || horiz <= 0) continue;
        const elDeg = Math.atan2(alt, horiz) * 180 / Math.PI;
        if (elDeg < minElevDeg) minElevDeg = elDeg;
    }
    if (minElevDeg >= 90) minElevDeg = 0;

    document.getElementById('search-elevation').value = Math.round(Math.max(0, minElevDeg) * 2) / 2;
}

// Auto pd-ref-range computation: set to max sensor-to-trajectory distance
function autoComputePdRefRange() {
    if (!document.getElementById('auto-search-sector').checked) return;

    let maxDistKm = 10;  // fallback default

    if (currentTrajectory && currentTrajectory.trajectory && currentTrajectory.trajectory.length > 0) {
        // Use trajectory data: find max horizontal distance from sensor origin
        const traj = currentTrajectory.trajectory;
        let maxD = 0;
        for (const pt of traj) {
            const px = (parseFloat(pt.x) || 0) / 1000;   // m → km
            const py = (parseFloat(pt.y) || 0) / 1000;
            const d = Math.sqrt(px * px + py * py);
            if (d > maxD) maxD = d;
        }
        if (maxD > 0) maxDistKm = maxD;
    } else {
        const sensor = getSensorLatLng();
        if (sensor && launchPoint) {
            const R = 6371;
            const dLat = (launchPoint.lat - sensor.lat) * Math.PI / 180;
            const dLon = (launchPoint.lon - sensor.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2)**2 + Math.cos(sensor.lat * Math.PI/180) * Math.cos(launchPoint.lat * Math.PI/180) * Math.sin(dLon/2)**2;
            maxDistKm = 2 * R * Math.asin(Math.sqrt(a));
            if (targetPoint) {
                const dLat2 = (targetPoint.lat - sensor.lat) * Math.PI / 180;
                const dLon2 = (targetPoint.lon - sensor.lon) * Math.PI / 180;
                const a2 = Math.sin(dLat2/2)**2 + Math.cos(sensor.lat * Math.PI/180) * Math.cos(targetPoint.lat * Math.PI/180) * Math.sin(dLon2/2)**2;
                maxDistKm = Math.max(maxDistKm, 2 * R * Math.asin(Math.sqrt(a2)));
            }
        }
    }

    document.getElementById('pd-ref-range').value = Math.round(Math.min(maxDistKm, 5000));
}

// Update coverage when sensor params change
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('radar-max-range').addEventListener('input', updateSensorCoverage);
    document.getElementById('azimuth-coverage').addEventListener('input', () => { autoComputeAntennaBearing(); autoComputeSearchSector(); autoComputeSearchElevation(); updateSensorCoverage(); });
    document.getElementById('search-min-range').addEventListener('input', updateSensorCoverage);
    document.getElementById('search-max-range').addEventListener('input', updateSensorCoverage);
    document.getElementById('launch-angle').addEventListener('input', () => { autoComputeSearchElevation(); });
    // Restore previous state from localStorage
    restoreStateFromStorage();
    // Validate beam allocation on page load
    validateBeamAllocation();
    // Initialize auto param visual state (after restore so saved values take effect)
    [['auto-max-range','radar-max-range']].forEach(([cbId, inputId]) => {
        const cb = document.getElementById(cbId);
        if (cb) toggleAutoParam(cb, inputId);
    });
    // Check for GPU errors
    checkGPUError();
});

// ========================================
// GPU Error Display
// ========================================
function checkGPUError() {
    fetch('/api/gpu-error-log')
        .then(response => response.json())
        .then(data => {
            if (data.exists && data.content) {
                document.getElementById('gpu-error-content').textContent = data.content;
                document.getElementById('gpu-error-banner').style.display = 'block';
            }
        })
        .catch(err => console.error('Failed to check GPU error log:', err));
}

// ========================================
// Location Preset Management
// ========================================
const BUILTIN_LOCATIONS = {
    launch: {
        'Musudan-ri': { lat: 40.856, lon: 129.666 },
        'Tongchang-ri': { lat: 39.660, lon: 124.705 },
        'Kittae-ryong': { lat: 39.170, lon: 127.110 },
    },
    target: {
        'Tokyo': { lat: 35.68, lon: 139.69 },
        'Osaka': { lat: 34.69, lon: 135.50 },
        'Sapporo': { lat: 43.06, lon: 141.35 },
        'Fukuoka': { lat: 33.59, lon: 130.40 },
    },
    sensor: {
        'Mishima': { lat: 34.79, lon: 131.13 },
    },
};

function getUserLocations(category) {
    try {
        return JSON.parse(localStorage.getItem(`fasttracker_loc_${category}`) || '{}');
    } catch { return {}; }
}

function saveUserLocations(category, locs) {
    localStorage.setItem(`fasttracker_loc_${category}`, JSON.stringify(locs));
}

function refreshLocationSelect(category) {
    const select = document.getElementById(`loc-${category}-select`);
    const prev = select.value;
    select.innerHTML = '';

    // Empty option
    const emptyOpt = document.createElement('option');
    emptyOpt.value = '';
    emptyOpt.textContent = '-- select --';
    select.appendChild(emptyOpt);

    // Built-in group
    const builtins = BUILTIN_LOCATIONS[category] || {};
    const builtinGroup = document.createElement('optgroup');
    builtinGroup.label = 'Built-in';
    for (const [name, loc] of Object.entries(builtins)) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        builtinGroup.appendChild(opt);
    }
    select.appendChild(builtinGroup);

    // User group
    const userLocs = getUserLocations(category);
    const userNames = Object.keys(userLocs);
    if (userNames.length > 0) {
        const userGroup = document.createElement('optgroup');
        userGroup.label = 'User';
        for (const name of userNames) {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            userGroup.appendChild(opt);
        }
        select.appendChild(userGroup);
    }

    if (prev && [...select.options].some(o => o.value === prev)) {
        select.value = prev;
    }
}

function getLocationByName(category, name) {
    const builtins = BUILTIN_LOCATIONS[category] || {};
    if (builtins[name]) return builtins[name];
    const userLocs = getUserLocations(category);
    return userLocs[name] || null;
}

function loadLocation(category) {
    const select = document.getElementById(`loc-${category}-select`);
    const name = select.value;
    if (!name) return;

    const loc = getLocationByName(category, name);
    if (!loc) return;

    if (category === 'launch') {
        setLaunchPoint(loc.lat, loc.lon);
    } else if (category === 'target') {
        setTargetPoint(loc.lat, loc.lon);
    } else if (category === 'sensor') {
        setSensorPoint(loc.lat, loc.lon);
    }

    // Fit map to show launch + target if both are set
    if (launchPoint && targetPoint) {
        map.fitBounds([
            [launchPoint.lat, launchPoint.lon],
            [targetPoint.lat, targetPoint.lon],
        ], { padding: [50, 50] });
    }

    updateStatus(`${category}: ${name} (${loc.lat.toFixed(2)}, ${loc.lon.toFixed(2)})`);
}

function saveCurrentLocation(category) {
    let lat, lon;
    if (category === 'launch') {
        if (!launchPoint) { alert('Launch point not set. Click on the map first.'); return; }
        lat = launchPoint.lat; lon = launchPoint.lon;
    } else if (category === 'target') {
        if (!targetPoint) { alert('Target point not set. Click on the map first.'); return; }
        lat = targetPoint.lat; lon = targetPoint.lon;
    } else if (category === 'sensor') {
        const s = getSensorLatLng();
        if (!s) { alert('Sensor position not set.'); return; }
        lat = s.lat; lon = s.lon;
    }

    const defaultName = `${lat.toFixed(2)}, ${lon.toFixed(2)}`;
    const name = prompt(`Save ${category} location as:`, defaultName);
    if (!name || !name.trim()) return;
    const trimmed = name.trim();

    if ((BUILTIN_LOCATIONS[category] || {})[trimmed]) {
        alert('Cannot overwrite built-in locations.');
        return;
    }

    const userLocs = getUserLocations(category);
    userLocs[trimmed] = { lat, lon };
    saveUserLocations(category, userLocs);

    refreshLocationSelect(category);
    document.getElementById(`loc-${category}-select`).value = trimmed;
    updateStatus(`Saved ${category}: ${trimmed}`);
}

function deleteSelectedLocation(category) {
    const select = document.getElementById(`loc-${category}-select`);
    const name = select.value;
    if (!name) return;

    if ((BUILTIN_LOCATIONS[category] || {})[name]) {
        alert('Built-in locations cannot be deleted.');
        return;
    }

    if (!confirm(`Delete "${name}" from ${category}?`)) return;

    const userLocs = getUserLocations(category);
    delete userLocs[name];
    saveUserLocations(category, userLocs);

    refreshLocationSelect(category);
    updateStatus(`Deleted ${category}: ${name}`);
}

// Initialize all location dropdowns
refreshLocationSelect('launch');
refreshLocationSelect('target');
refreshLocationSelect('sensor');

// Defaults
document.getElementById('loc-launch-select').value = 'Musudan-ri';
loadLocation('launch');
document.getElementById('loc-target-select').value = 'Tokyo';
loadLocation('target');
document.getElementById('loc-sensor-select').value = 'Mishima';
loadLocation('sensor');

// ========================================
// Panel switching
// ========================================
function switchPanel(name) {
    document.querySelectorAll('.object-list-item').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.detail-section').forEach(el => el.classList.remove('active'));
    document.querySelector(`.object-list-item[onclick="switchPanel('${name}')"]`).classList.add('active');
    document.getElementById('panel-' + name).classList.add('active');
}

// ========================================
// Viz Panel Tab Switching
// ========================================
let activeVizTab = 'trajectory';

function switchVizTab(name) {
    const tab = document.querySelector(`.viz-tab[data-viz-tab="${name}"]`);
    if (tab && tab.classList.contains('disabled')) return;
    document.querySelectorAll('.viz-tab').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.viz-tab-content').forEach(el => el.classList.remove('active'));
    if (tab) tab.classList.add('active');
    document.getElementById('viz-' + name).classList.add('active');
    activeVizTab = name;
    // Plotly resize after tab becomes visible
    setTimeout(() => {
        if (name === 'trajectory' || name === 'tracking') {
            const plotDiv = document.getElementById('plot3d-' + name);
            if (plotDiv && plotDiv.data) Plotly.Plots.resize(plotDiv);
        } else if (name === 'evaluation') {
            ['eval-chart-pos', 'eval-chart-ospa', 'eval-chart-tracks', 'eval-chart-detect'].forEach(id => {
                const el = document.getElementById(id);
                if (el && el.data) Plotly.Plots.resize(el);
            });
        }
    }, 50);
}

function enableVizTab(name) {
    const tab = document.querySelector(`.viz-tab[data-viz-tab="${name}"]`);
    if (tab) tab.classList.remove('disabled');
}

function disableVizTab(name) {
    const tab = document.querySelector(`.viz-tab[data-viz-tab="${name}"]`);
    if (tab) tab.classList.add('disabled');
}

// ========================================
// Separation toggle
// ========================================
function toggleSeparationParams() {
    const enabled = document.getElementById('enable-separation').checked;
    document.getElementById('sep-params').style.display = enabled ? 'flex' : 'none';
}

// HGV defaults for typical parameters
const BALLISTIC_DEFAULTS = {
    launch_angle: 40, boost_duration: 65, initial_mass: 20000,
    fuel_fraction: 0.70, specific_impulse: 250, drag_coefficient: 0.3,
    cross_section: 1.0, boost_accel: 30,
};
const HGV_DEFAULTS = {
    launch_angle: 20, boost_duration: 55, initial_mass: 18000,
    fuel_fraction: 0.70, specific_impulse: 250, drag_coefficient: 0.20,
    cross_section: 0.7, boost_accel: 30,
};

function onMissileTypeChange() {
    const isHgv = document.getElementById('missile-type').value === 'hgv';

    // Show/hide HGV-specific params
    document.querySelectorAll('.hgv-only-param').forEach(el => {
        el.style.display = isHgv ? 'flex' : 'none';
    });
    // Show/hide ballistic-only params
    document.querySelectorAll('.ballistic-only-param').forEach(el => {
        el.style.display = isHgv ? 'none' : 'flex';
    });

    // Apply type-specific defaults
    const defaults = isHgv ? HGV_DEFAULTS : BALLISTIC_DEFAULTS;
    document.getElementById('launch-angle').value = defaults.launch_angle;
    document.getElementById('boost-duration').value = defaults.boost_duration;
    document.getElementById('initial-mass').value = defaults.initial_mass;
    document.getElementById('fuel-fraction').value = defaults.fuel_fraction;
    document.getElementById('specific-impulse').value = defaults.specific_impulse;
    document.getElementById('drag-coefficient').value = defaults.drag_coefficient;
    document.getElementById('cross-section').value = defaults.cross_section;
    document.getElementById('boost-accel').value = defaults.boost_accel;

    // HGV always has separation enabled
    if (isHgv) {
        document.getElementById('enable-separation').checked = true;
        toggleSeparationParams();
    }
}

// ========================================
// Generate Trajectory
// ========================================
async function generateTrajectory() {
    if (!launchPoint || !targetPoint) {
        alert('Please set both launch and target points on the map.');
        return;
    }

    const missileType = document.getElementById('missile-type').value;
    const isHgv = missileType === 'hgv';
    const autoAdjust = document.getElementById('auto-adjust').checked;
    const loadMsg = isHgv ? 'Computing HGV trajectory...'
        : (autoAdjust ? 'Auto-adjusting parameters...' : 'Generating trajectory...');
    showLoading(loadMsg);

    const targetAltKm = parseFloat(document.getElementById('target-max-altitude').value) || 0;
    const params = {
        missile_type: missileType,
        boost_duration: parseFloat(document.getElementById('boost-duration').value),
        boost_acceleration: parseFloat(document.getElementById('boost-accel').value),
        launch_angle: parseFloat(document.getElementById('launch-angle').value) * Math.PI / 180,
        dt: parseFloat(document.getElementById('time-step').value),
        auto_adjust: autoAdjust,
        initial_mass: parseFloat(document.getElementById('initial-mass').value),
        fuel_fraction: parseFloat(document.getElementById('fuel-fraction').value),
        specific_impulse: parseFloat(document.getElementById('specific-impulse').value),
        drag_coefficient: parseFloat(document.getElementById('drag-coefficient').value),
        cross_section_area: parseFloat(document.getElementById('cross-section').value),
        target_max_altitude: targetAltKm * 1000,
        lock_angle: document.getElementById('lock-angle').checked,
        lock_isp: document.getElementById('lock-isp').checked,
        lock_fuel: document.getElementById('lock-fuel').checked,
        enable_separation: document.getElementById('enable-separation').checked,
        warhead_mass_fraction: parseFloat(document.getElementById('warhead-mass-frac').value) / 100.0,
    };

    // HGV-specific parameters (in meters/radians for backend)
    if (isHgv) {
        params.cruise_altitude = parseFloat(document.getElementById('cruise-altitude').value) * 1000;
        params.glide_ratio = parseFloat(document.getElementById('glide-ratio').value);
        params.terminal_dive_range = parseFloat(document.getElementById('terminal-dive-range').value) * 1000;
        params.pullup_duration = 30.0;  // fixed internal
        params.bank_angle_max = parseFloat(document.getElementById('bank-angle-max').value) * Math.PI / 180;
        params.num_skips = parseInt(document.getElementById('num-skips').value) || 0;
    }

    try {
        const response = await fetch('/api/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                launch: launchPoint,
                target: targetPoint,
                params: params,
            }),
        });

        const data = await response.json();
        hideLoading();

        if (data.success) {
            currentTrajectory = data;
            drawTrajectoryOnMap(data);
            draw3DVisualization(data);
            updateSummary(data.summary);
            document.getElementById('btn-run-tracker').disabled = false;
            autoComputeSearchElevation();
            autoComputePdRefRange();

            // Handle auto-adjust results
            const adjInfo = document.getElementById('auto-adjust-info');
            if (data.auto_adjust && data.auto_adjust.adjusted) {
                const adj = data.auto_adjust;
                const changes = [];

                // Update input fields with adjusted values
                const adjAngleDeg = (adj.launch_angle * 180 / Math.PI).toFixed(1);
                const origAngle = document.getElementById('launch-angle').value;
                if (Math.abs(adj.launch_angle - parseFloat(origAngle) * Math.PI / 180) > 0.01) {
                    document.getElementById('launch-angle').value = adjAngleDeg;
                    changes.push(`Angle: ${adjAngleDeg}°`);
                }

                const origIsp = parseFloat(document.getElementById('specific-impulse').value);
                if (Math.abs(adj.specific_impulse - origIsp) > 0.5) {
                    document.getElementById('specific-impulse').value = adj.specific_impulse;
                    changes.push(`Isp: ${adj.specific_impulse}s`);
                }

                const origFF = parseFloat(document.getElementById('fuel-fraction').value);
                if (Math.abs(adj.fuel_fraction - origFF) > 0.005) {
                    document.getElementById('fuel-fraction').value = adj.fuel_fraction;
                    const fuelMassStr = adj.fuel_mass != null ? ` (${adj.fuel_mass.toFixed(0)}kg)` : '';
                    changes.push(`Fuel: ${adj.fuel_fraction.toFixed(3)}${fuelMassStr}`);
                }

                adjInfo.textContent = changes.length > 0
                    ? `Adjusted: ${changes.join(', ')}`
                    : 'Angle adjusted';
                adjInfo.style.color = '#ffaa00';

                updateStatus(`Auto-adjusted: ${changes.join(', ')} | Impact: ${adj.impact_distance_km} km from target`);
            } else {
                adjInfo.textContent = '';
                updateStatus(`Trajectory generated: ${data.summary.range_km} km, ${data.summary.flight_duration} s`);
            }
            saveStateToStorage();
        } else {
            alert('Error: ' + (data.error || 'Unknown error'));
        }
    } catch (err) {
        hideLoading();
        alert('Server error: ' + err.message);
    }
}

// ========================================
// Draw trajectory on map
// ========================================
function drawTrajectoryOnMap(data) {
    if (trajectoryLine) map.removeLayer(trajectoryLine);

    const latlons = data.plotly.latlons;
    const phases = data.plotly.trajectory.phases;
    const coords = latlons.map(ll => [ll[0], ll[1]]);

    // Use a LayerGroup to track all layers for proper cleanup
    const layerGroup = L.layerGroup();

    // Phase-colored polyline segments
    const phaseColors = {
        'BOOST': '#ff8c00',      // Orange - ブースト上昇
        'MIDCOURSE': '#32c8ff',  // Cyan - 中間飛翔（放物線）
        'TERMINAL': '#ff2050',   // Red - 終末落下・機動
        'PULLUP': '#ffcc00',     // Gold - HGV引き起こし遷移
        'GLIDE': '#9d4edd'       // Purple - HGV超音速滑空
    };
    let currentPhase = phases[0];
    let segment = [coords[0]];

    for (let i = 1; i < coords.length; i++) {
        if (phases[i] !== currentPhase || i === coords.length - 1) {
            segment.push(coords[i]);
            layerGroup.addLayer(L.polyline(segment, {
                color: phaseColors[currentPhase] || '#fff',
                weight: 3,
                opacity: 0.9,
            }));
            currentPhase = phases[i];
            segment = [coords[i]];
        } else {
            segment.push(coords[i]);
        }
    }

    // Impact point marker (where warhead actually lands)
    if (coords.length > 0) {
        const impactCoord = coords[coords.length - 1];
        const impactIcon = L.divIcon({
            html: '<div style="background:#ff2050; width:12px; height:12px; border-radius:0; border:2px solid #fff; transform:rotate(45deg); box-shadow:0 0 8px #ff2050;"></div>',
            iconSize: [12, 12],
            iconAnchor: [6, 6],
            className: '',
        });
        layerGroup.addLayer(L.marker(impactCoord, { icon: impactIcon })
            .bindTooltip('Warhead Impact', { permanent: false }));

        // Check distance from impact to target
        if (targetPoint) {
            const dLat = impactCoord[0] - targetPoint.lat;
            const dLon = impactCoord[1] - targetPoint.lon;
            const distKm = Math.sqrt(dLat * dLat + dLon * dLon) * 111.0; // rough km
            if (distKm > 50) {
                updateStatus(`Warning: Impact point is ~${Math.round(distKm)} km from target. Adjust physics parameters for longer range.`);
            }
        }
    }

    // Booster trajectory on map (if separation enabled)
    if (data.plotly.booster_latlons && data.plotly.booster_latlons.length > 0) {
        const boosterCoords = data.plotly.booster_latlons.map(ll => [ll[0], ll[1]]);
        layerGroup.addLayer(L.polyline(boosterCoords, {
            color: '#888',
            weight: 2,
            opacity: 0.7,
            dashArray: '6,6',
        }));

        // Booster impact marker
        const boosterImpact = boosterCoords[boosterCoords.length - 1];
        const boosterIcon = L.divIcon({
            html: '<div style="background:#888; width:10px; height:10px; border-radius:0; border:2px solid #fff; transform:rotate(45deg); box-shadow:0 0 6px #888;"></div>',
            iconSize: [10, 10],
            iconAnchor: [5, 5],
            className: '',
        });
        layerGroup.addLayer(L.marker(boosterImpact, { icon: boosterIcon })
            .bindTooltip('Booster Impact', { permanent: false }));
    }

    layerGroup.addTo(map);
    trajectoryLine = layerGroup;
}

// ========================================
// 3D Visualization
// ========================================
function draw3DVisualization(data) {
    const t = data.plotly.trajectory;

    // Phase-colored line segments (matching map style)
    const phaseColors = {
        'BOOST': '#ff8c00',      // Orange - ブースト上昇
        'MIDCOURSE': '#32c8ff',  // Cyan - 中間飛翔（放物線）
        'TERMINAL': '#ff2050',   // Red - 終末落下・機動
        'PULLUP': '#ffcc00',     // Gold - HGV引き起こし遷移
        'GLIDE': '#9d4edd'       // Purple - HGV超音速滑空
    };
    const phaseNames = {
        'BOOST': 'Boost',
        'MIDCOURSE': 'Midcourse',
        'TERMINAL': 'Terminal',
        'PULLUP': 'Pullup (HGV)',
        'GLIDE': 'Glide (HGV)'
    };
    const plotTraces = [];
    const shownPhases = new Set();
    {
        let segStart = 0;
        let curPhase = t.phases[0];
        for (let i = 1; i <= t.x.length; i++) {
            if (i === t.x.length || t.phases[i] !== curPhase) {
                const end = Math.min(i + 1, t.x.length);
                const first = !shownPhases.has(curPhase);
                shownPhases.add(curPhase);
                plotTraces.push({
                    type: 'scatter3d', mode: 'lines',
                    x: t.x.slice(segStart, end),
                    y: t.y.slice(segStart, end),
                    z: t.z.slice(segStart, end),
                    name: phaseNames[curPhase] || curPhase,
                    line: { color: phaseColors[curPhase] || '#fff', width: 4 },
                    text: t.text.slice(segStart, end),
                    hoverinfo: 'text',
                    legendgroup: curPhase,
                    showlegend: first,
                });
                if (i < t.x.length) {
                    curPhase = t.phases[i];
                    segStart = i;
                }
            }
        }
    }

    // Launch marker (small on chart, legend via dummy trace)
    plotTraces.push({
        type: 'scatter3d', mode: 'markers',
        x: [t.x[0]], y: [t.y[0]], z: [t.z[0]],
        marker: { size: 3.5, color: '#e94560', symbol: 'circle', line: { color: 'white', width: 1 } },
        hovertext: 'Launch Point', hoverinfo: 'text',
        legendgroup: 'launch', showlegend: false,
    });
    plotTraces.push({
        type: 'scatter3d', mode: 'markers',
        x: [null], y: [null], z: [null],
        name: 'Launch',
        marker: { size: 7, color: '#e94560', symbol: 'circle', line: { color: 'white', width: 1 } },
        hoverinfo: 'skip',
        legendgroup: 'launch',
    });

    // Warhead impact marker (small on chart, legend via dummy trace)
    const lastIdx = t.x.length - 1;
    plotTraces.push({
        type: 'scatter3d', mode: 'markers',
        x: [t.x[lastIdx]], y: [t.y[lastIdx]], z: [t.z[lastIdx]],
        marker: { size: 3.5, color: '#ff2050', symbol: 'diamond', line: { color: 'white', width: 1 } },
        hovertext: 'Warhead Impact', hoverinfo: 'text',
        legendgroup: 'warhead', showlegend: false,
    });
    plotTraces.push({
        type: 'scatter3d', mode: 'markers',
        x: [null], y: [null], z: [null],
        name: 'Impact (Warhead)',
        marker: { size: 7, color: '#ff2050', symbol: 'diamond', line: { color: 'white', width: 1 } },
        hoverinfo: 'skip',
        legendgroup: 'warhead',
    });

    // Booster trajectory (if separation enabled)
    if (data.plotly.booster) {
        const b = data.plotly.booster;
        plotTraces.push({
            type: 'scatter3d', mode: 'lines',
            x: b.x, y: b.y, z: b.z,
            name: 'Booster',
            line: { color: '#888', width: 2, dash: 'dash' },
            text: b.text, hoverinfo: 'text',
        });

        const bLastIdx = b.x.length - 1;
        plotTraces.push({
            type: 'scatter3d', mode: 'markers',
            x: [b.x[bLastIdx]], y: [b.y[bLastIdx]], z: [b.z[bLastIdx]],
            marker: { size: 2.5, color: '#888', symbol: 'diamond', line: { color: 'white', width: 1 } },
            hovertext: 'Booster Impact', hoverinfo: 'text',
            legendgroup: 'booster_impact', showlegend: false,
        });
        plotTraces.push({
            type: 'scatter3d', mode: 'markers',
            x: [null], y: [null], z: [null],
            name: 'Impact (Booster)',
            marker: { size: 5, color: '#888', symbol: 'diamond', line: { color: 'white', width: 1 } },
            hoverinfo: 'skip',
            legendgroup: 'booster_impact',
        });
    }

    // Calculate equal ranges for all axes to prevent distortion
    let xMin = Math.min(...t.x), xMax = Math.max(...t.x);
    let yMin = Math.min(...t.y), yMax = Math.max(...t.y);
    let zMin = Math.min(...t.z), zMax = Math.max(...t.z);
    if (data.plotly.booster) {
        const b = data.plotly.booster;
        xMin = Math.min(xMin, ...b.x); xMax = Math.max(xMax, ...b.x);
        yMin = Math.min(yMin, ...b.y); yMax = Math.max(yMax, ...b.y);
        zMin = Math.min(zMin, ...b.z); zMax = Math.max(zMax, ...b.z);
    }
    const xRange = xMax - xMin, yRange = yMax - yMin, zRange = zMax - zMin;
    const maxRange = Math.max(xRange, yRange, zRange);
    const xCenter = (xMin + xMax) / 2, yCenter = (yMin + yMax) / 2, zCenter = (zMin + zMax) / 2;
    const axisRange = maxRange * 0.55; // 10% padding

    const layout = {
        scene: {
            xaxis: {
                title: 'X (km)',
                backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa',
                range: [xCenter - axisRange, xCenter + axisRange]
            },
            yaxis: {
                title: 'Y (km)',
                backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa',
                range: [yCenter - axisRange, yCenter + axisRange]
            },
            zaxis: {
                title: 'Altitude (km)',
                backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa',
                range: [zCenter - axisRange, zCenter + axisRange]
            },
            aspectmode: 'cube',  // 1:1:1 aspect ratio for true spatial representation
        },
        paper_bgcolor: '#16213e',
        plot_bgcolor: '#16213e',
        font: { color: '#e0e0e0' },
        margin: { l: 0, r: 0, t: 30, b: 0 },
        title: { text: 'Ballistic Missile Trajectory', font: { size: 14, color: '#e94560' } },
        legend: { x: 0.02, y: 0.98, bgcolor: 'rgba(0,0,0,0.5)' },
    };

    Plotly.newPlot('plot3d-trajectory', plotTraces, layout, {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['toImage'],
    });

    let vizInfo = `Range: ${data.summary.range_km} km | Duration: ${data.summary.flight_duration} s | Max Alt: ${(data.summary.max_altitude/1000).toFixed(1)} km`;
    if (data.summary.separation_time != null) {
        vizInfo += ` | Sep: ${data.summary.separation_time.toFixed(0)}s`;
    }
    document.getElementById('viz-info').textContent = vizInfo;

    // Tab management: enable trajectory, reset tracking/evaluation
    enableVizTab('trajectory');
    switchVizTab('trajectory');
    Plotly.purge('plot3d-tracking');
    Plotly.purge('plot-timeline');
    document.getElementById('eval-tab-content').innerHTML = '<div class="eval-placeholder">Run Tracker to see evaluation metrics</div>';
}

// ========================================
// Run Tracker (async with progress + cancel)
// ========================================
let _currentTrackerJobId = null;
let _trackerPollTimer = null;

function _buildTrackerParams() {
    const missileType = document.getElementById('missile-type').value;
    const isHgv = missileType === 'hgv';
    const p = {
        missile_type: missileType,
        launch_angle: parseFloat(document.getElementById('launch-angle').value) * Math.PI / 180,
        boost_duration: parseFloat(document.getElementById('boost-duration').value),
        boost_acceleration: parseFloat(document.getElementById('boost-accel').value),
        initial_mass: parseFloat(document.getElementById('initial-mass').value),
        fuel_fraction: parseFloat(document.getElementById('fuel-fraction').value),
        specific_impulse: parseFloat(document.getElementById('specific-impulse').value),
        drag_coefficient: parseFloat(document.getElementById('drag-coefficient').value),
        cross_section_area: parseFloat(document.getElementById('cross-section').value),
        sensor_lat: getSensorLatLng()?.lat,
        sensor_lon: getSensorLatLng()?.lon,
        radar_min_range: parseFloat(document.getElementById('radar-min-range').value) * 1000,
        radar_max_range: document.getElementById('auto-max-range').checked ? 0 : parseFloat(document.getElementById('radar-max-range').value) * 1000,
        azimuth_coverage: parseFloat(document.getElementById('azimuth-coverage').value) * Math.PI / 180,
        min_elevation: parseFloat(document.getElementById('min-elevation').value) * Math.PI / 180,
        max_elevation: parseFloat(document.getElementById('max-elevation').value) * Math.PI / 180,
        enable_separation: document.getElementById('enable-separation').checked,
        warhead_mass_fraction: parseFloat(document.getElementById('warhead-mass-frac').value) / 100.0,
        cluster_count: parseInt(document.getElementById('cluster-count').value) || 0,
        cluster_spread: parseFloat(document.getElementById('cluster-spread').value) * 1000,
        launch_time_spread: parseFloat(document.getElementById('launch-time-spread').value) || 5,
        beam_width: parseFloat(document.getElementById('beam-width').value) * Math.PI / 180,
        num_beams: parseInt(document.getElementById('num-beams').value),
        min_search_beams: parseInt(document.getElementById('min-search-beams').value),
        track_confirmed_only: document.getElementById('track-priority').value === 'confirmed',
        search_sector: (parseFloat(document.getElementById('search-sector').value) || 0) > 0
            ? parseFloat(document.getElementById('search-sector').value) * Math.PI / 180 : -1,
        search_center: parseFloat(document.getElementById('search-center').value) || 0,
        antenna_boresight: parseFloat(document.getElementById('antenna-bearing').value) || 0,
        search_elevation: parseFloat(document.getElementById('search-elevation').value) || 0,
        search_min_range: parseFloat(document.getElementById('search-min-range').value) * 1000,
        search_max_range: parseFloat(document.getElementById('search-max-range').value) * 1000,
        track_range_width: parseFloat(document.getElementById('track-range-width').value) * 1000,
        pfa: parseFloat(document.getElementById('pfa').value) || 1e-6,
        pd_ref: parseFloat(document.getElementById('pd-ref').value),
        pd_ref_range_km: parseFloat(document.getElementById('pd-ref-range').value),
        range_noise: parseFloat(document.getElementById('range-noise').value),
        azimuth_noise: parseFloat(document.getElementById('azimuth-noise').value) * Math.PI / 180,
        elevation_noise: parseFloat(document.getElementById('elevation-noise').value) * Math.PI / 180,
        doppler_noise: parseFloat(document.getElementById('doppler-noise').value),
        gate_threshold: parseFloat(document.getElementById('gate-threshold').value),
        confirm_hits: parseInt(document.getElementById('confirm-hits').value),
        delete_misses: parseInt(document.getElementById('delete-misses').value),
        min_snr: parseFloat(document.getElementById('min-snr').value),
        process_pos_noise: parseFloat(document.getElementById('process-pos-noise').value),
        process_vel_noise: parseFloat(document.getElementById('process-vel-noise').value),
        process_acc_noise: parseFloat(document.getElementById('process-acc-noise').value),
        ukf_alpha: parseFloat(document.getElementById('ukf-alpha').value),
        ukf_beta: parseFloat(document.getElementById('ukf-beta').value),
        ukf_kappa: parseFloat(document.getElementById('ukf-kappa').value),
        max_distance: parseFloat(document.getElementById('max-distance').value),
        imm_cv_cv: parseFloat(document.getElementById('imm-cv-cv').value),
        imm_cv_bal: parseFloat(document.getElementById('imm-cv-bal').value),
        imm_cv_ct: parseFloat(document.getElementById('imm-cv-ct').value),
        imm_bal_cv: parseFloat(document.getElementById('imm-bal-cv').value),
        imm_bal_bal: parseFloat(document.getElementById('imm-bal-bal').value),
        imm_bal_ct: parseFloat(document.getElementById('imm-bal-ct').value),
        imm_ct_cv: parseFloat(document.getElementById('imm-ct-cv').value),
        imm_ct_bal: parseFloat(document.getElementById('imm-ct-bal').value),
        imm_ct_ct: parseFloat(document.getElementById('imm-ct-ct').value),
        imm_cv_noise: parseFloat(document.getElementById('imm-cv-noise').value),
        imm_bal_noise: parseFloat(document.getElementById('imm-bal-noise').value),
        imm_ct_noise: parseFloat(document.getElementById('imm-ct-noise').value),
        num_runs: parseInt(document.getElementById('num-runs').value),
        seed: parseInt(document.getElementById('random-seed').value),
    };
    if (isHgv) {
        p.cruise_altitude = parseFloat(document.getElementById('cruise-altitude').value) * 1000;
        p.glide_ratio = parseFloat(document.getElementById('glide-ratio').value);
        p.terminal_dive_range = parseFloat(document.getElementById('terminal-dive-range').value) * 1000;
        p.pullup_duration = 30.0;
        p.bank_angle_max = parseFloat(document.getElementById('bank-angle-max').value) * Math.PI / 180;
        p.num_skips = parseInt(document.getElementById('num-skips').value) || 0;
    }
    return p;
}

async function _renderTrackerResult(data) {
    const yieldToUI = () => new Promise(resolve => setTimeout(resolve, 0));
    const gt = data.ground_truth || [];
    const meas = data.measurements || [];
    const tracks = data.tracks || [];
    console.log(`[Render] gt=${gt.length} meas=${meas.length} tracks=${tracks.length}`);

    updateTrackerProgress(100, 'Rendering 3D view...');
    updateStatus('Rendering 3D view...');
    await yieldToUI();
    console.time('[Render] draw3DWithTracks');
    draw3DWithTracks(data);
    console.timeEnd('[Render] draw3DWithTracks');

    updateTrackerProgress(100, 'Rendering timeline...');
    updateStatus('Rendering timeline...');
    await yieldToUI();
    console.time('[Render] drawTimeline');
    drawTimeline(data);
    console.timeEnd('[Render] drawTimeline');

    updateTrackerProgress(100, 'Rendering evaluation...');
    updateStatus('Rendering evaluation...');
    await yieldToUI();
    console.time('[Render] displayEvaluation');
    await displayEvaluation(data);
    console.timeEnd('[Render] displayEvaluation');

    updateTrackerProgress(100, 'Rendering console output...');
    await yieldToUI();
    console.time('[Render] displayConsole');
    displayConsole(data);
    console.timeEnd('[Render] displayConsole');

    showResolvedParams(data.eval_summary);
    enableVizTab('tracking');
    enableVizTab('evaluation');
    enableVizTab('timeline');
    enableVizTab('console');
    switchVizTab('tracking');
    const numRuns = parseInt(document.getElementById('num-runs').value);
    updateStatus(`Tracker simulation complete${numRuns > 1 ? ` (${numRuns} runs)` : ''}`);
    saveStateToStorage();
}

function _pollTrackerJob(jobId) {
    return new Promise((resolve, reject) => {
        _trackerPollTimer = setInterval(async () => {
            try {
                const res = await fetch(`/api/run-tracker-status/${jobId}`);
                const data = await res.json();
                if (!data.success) {
                    clearInterval(_trackerPollTimer);
                    reject(new Error(data.error || 'Job failed'));
                    return;
                }
                updateTrackerProgress(data.progress_pct, data.progress_msg);
                if (data.status === 'complete') {
                    clearInterval(_trackerPollTimer);
                    resolve(data.result);
                } else if (data.status === 'error') {
                    clearInterval(_trackerPollTimer);
                    reject(new Error(data.error || 'Job error'));
                } else if (data.status === 'cancelled') {
                    clearInterval(_trackerPollTimer);
                    resolve(null);
                }
            } catch (err) {
                clearInterval(_trackerPollTimer);
                reject(err);
            }
        }, 500);
    });
}

async function cancelTracker() {
    if (!_currentTrackerJobId) return;
    clearInterval(_trackerPollTimer);
    try {
        await fetch(`/api/run-tracker-cancel/${_currentTrackerJobId}`, { method: 'POST' });
    } catch (_) {}
    _currentTrackerJobId = null;
    hideLoading();
    document.getElementById('btn-run-tracker').disabled = false;
    updateStatus('Tracker cancelled');
}

async function runTracker() {
    if (!currentTrajectory) return;

    // Ensure search elevation and pd-ref-range are up-to-date before building params
    autoComputeSearchElevation();
    autoComputePdRefRange();

    const numRuns = parseInt(document.getElementById('num-runs').value) || 1;
    const clusterCount = parseInt(document.getElementById('cluster-count').value) || 0;
    const loadMsg = numRuns > 1
        ? `Running FastTracker simulation (${numRuns} runs)...`
        : clusterCount > 0
            ? `Running FastTracker (${clusterCount + 1} targets, cluster mode)...`
            : 'Running FastTracker simulation...';

    showTrackerLoading(loadMsg);
    document.getElementById('btn-run-tracker').disabled = true;

    try {
        const params = _buildTrackerParams();
        const startRes = await fetch('/api/run-tracker-start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ trajectory: currentTrajectory.trajectory, params }),
        });
        const startData = await startRes.json();
        if (!startData.success) throw new Error(startData.error || 'Failed to start job');

        _currentTrackerJobId = startData.job_id;
        const result = await _pollTrackerJob(startData.job_id);
        _currentTrackerJobId = null;

        if (result === null) {
            // cancelled
            return;
        }
        if (result.success) {
            await _renderTrackerResult(result);
        } else {
            alert('Tracker error: ' + (result.error || 'Unknown error'));
            updateStatus('Tracker failed: ' + (result.error || ''));
        }
    } catch (err) {
        _currentTrackerJobId = null;
        alert('Server error: ' + err.message);
        updateStatus('Tracker failed: ' + err.message);
    } finally {
        hideLoading();
        document.getElementById('btn-run-tracker').disabled = false;
    }
}

function toggleAutoParam(checkbox, inputId) {
    const input = document.getElementById(inputId);
    if (!input) return;
    input.disabled = checkbox.checked;
    if (checkbox.checked) {
        input.style.opacity = '0.4';
    } else {
        input.style.opacity = '1';
    }
}

function showResolvedParams(summary) {
    const r = summary && summary.resolved;
    // Mapping: { resolved_key: [spanId, autoCheckboxId, inputId, fmtSpan, fmtInput] }
    const defs = {
        radar_max_range: ['resolved-max-range', 'auto-max-range', 'radar-max-range',
                          v => `(=${(v/1000).toFixed(0)} km)`, v => (v/1000).toFixed(0)],
        snr_ref:         ['resolved-snr-ref',    null,             null,
                          null, null],  // Custom formatting below
    };
    for (const [key, [spanId, autoId, inputId, fmtSpan, fmtInput]] of Object.entries(defs)) {
        const span = document.getElementById(spanId);
        const autoCheck = autoId ? document.getElementById(autoId) : null;
        const input = inputId ? document.getElementById(inputId) : null;
        if (!span) continue;
        if (r && r[key] != null && fmtSpan) {
            if (autoCheck === null || autoCheck.checked) {
                span.textContent = fmtSpan(r[key]);
                if (input && fmtInput) input.value = fmtInput(r[key]);
            } else {
                span.textContent = '';
            }
        } else if (key === 'snr_ref') {
            // Custom SNR display: show both SNR@1km and SNR@ref_range
            continue;  // Handle below
        } else {
            span.textContent = '';
        }
    }

    // Custom formatting for SNR display (only show SNR at reference distance)
    const snrSpan = document.getElementById('resolved-snr-ref');
    if (snrSpan && r) {
        if (r.snr_at_ref_range != null && r.det_ref_range_m != null) {
            const refRangeKm = (r.det_ref_range_m / 1000).toFixed(0);
            snrSpan.textContent = `(SNR@${refRangeKm}km=${r.snr_at_ref_range.toFixed(1)} dB)`;
        } else {
            snrSpan.textContent = '';
        }
    }
}

function draw3DWithTracks(data) {
    const gt = data.ground_truth;
    const tracks = data.tracks;
    const measurements = data.measurements || [];

    if (!gt.length) return;

    // Sensor position (origin of the plot)
    const sx = (data.sensor_x || 0) / 1000;  // km
    const sy = (data.sensor_y || 0) / 1000;

    // Build altitude lookup from ground truth data (average altitude per frame, in km)
    // This is more reliable than currentTrajectory for multi-target scenarios
    const altByFrame = {};
    gt.forEach(r => {
        if (r.z != null) {
            if (!altByFrame[r.frame]) altByFrame[r.frame] = { sum: 0, count: 0, time: r.time };
            altByFrame[r.frame].sum += r.z / 1000;
            altByFrame[r.frame].count++;
        }
    });
    const altLookup = Object.values(altByFrame)
        .map(v => ({ time: v.time, alt: v.sum / v.count }))
        .sort((a, b) => a.time - b.time);

    // Get the max flight time from GT data
    const maxTrajectoryTime = gt.length > 0
        ? gt.reduce((mx, r) => Math.max(mx, r.time), 0)
        : Infinity;

    // Interpolate average altitude by time (for measurements which lack altitude)
    function getAltitude(time) {
        if (altLookup.length === 0) return 0;
        if (time <= altLookup[0].time) return altLookup[0].alt;
        if (time >= altLookup[altLookup.length - 1].time) return altLookup[altLookup.length - 1].alt;
        let lo = 0, hi = altLookup.length - 1;
        while (lo < hi - 1) {
            const mid = (lo + hi) >> 1;
            if (altLookup[mid].time <= time) lo = mid; else hi = mid;
        }
        const t0 = altLookup[lo].time, t1 = altLookup[hi].time;
        const frac = (t1 > t0) ? (time - t0) / (t1 - t0) : 0;
        return altLookup[lo].alt + frac * (altLookup[hi].alt - altLookup[lo].alt);
    }

    // Build GT index by frame for altitude lookup (detections and tracks)
    const gtByFrame = {};
    gt.forEach(r => {
        const f = r.frame;
        if (!gtByFrame[f]) gtByFrame[f] = [];
        gtByFrame[f].push(r);
    });

    // Get altitude for a detection by matching to nearest GT target at same frame
    function getDetectionAltitude(m) {
        const frameGt = gtByFrame[m.frame];
        if (!frameGt || frameGt.length === 0) return getAltitude(m.time);
        if (frameGt.length === 1) {
            return (frameGt[0].z != null) ? frameGt[0].z / 1000 : getAltitude(m.time);
        }
        // Convert detection polar coords to simulation cartesian (meters)
        const el = m.elevation || 0;
        const r_horiz = m.range * Math.cos(el);
        const det_x = sx * 1000 + r_horiz * Math.cos(m.azimuth);
        const det_y = sy * 1000 + r_horiz * Math.sin(m.azimuth);
        let bestDist = Infinity, bestAlt = 0;
        for (const g of frameGt) {
            const dx = det_x - g.x, dy = det_y - g.y;
            const d = dx * dx + dy * dy;
            if (d < bestDist) {
                bestDist = d;
                bestAlt = (g.z != null) ? g.z / 1000 : getAltitude(g.time);
            }
        }
        return bestAlt;
    }

    const traces = [];

    // Sensor origin marker
    traces.push({
        type: 'scatter3d', mode: 'markers',
        x: [0], y: [0], z: [0],
        marker: { size: 5, color: '#32ff32', symbol: 'diamond', line: { color: 'white', width: 1 } },
        hovertext: 'Sensor (Origin)', hoverinfo: 'text',
        legendgroup: 'sensor', showlegend: false,
    });
    traces.push({
        type: 'scatter3d', mode: 'markers',
        x: [null], y: [null], z: [null],
        name: 'Sensor',
        marker: { size: 8, color: '#32ff32', symbol: 'diamond', line: { color: 'white', width: 1 } },
        hoverinfo: 'skip',
        legendgroup: 'sensor',
    });

    // === 3D Search Coverage Volume ===
    (function() {
        try {
            var covSElevDeg  = parseFloat(document.getElementById('search-elevation').value) || 0;
            var covBwDeg     = parseFloat(document.getElementById('beam-width').value) || 3;
            var covFovDeg    = parseFloat(document.getElementById('azimuth-coverage').value) || 360;
            var covBsightDeg = parseFloat(document.getElementById('antenna-bearing').value) || 0;
            var covSectDeg   = parseFloat(document.getElementById('search-sector').value) || 0;
            var covSCenDeg   = parseFloat(document.getElementById('search-center').value) || 0;
            var covMinRangeKm = parseFloat(document.getElementById('search-min-range').value) || 0;
            var covSearchMaxKm = parseFloat(document.getElementById('search-max-range').value) || 0;

            // Max range: parse actual value from C++ stdout (most accurate)
            var covMaxRangeKm = 0;
            if (data.stdout) {
                var covRangeMatch = data.stdout.match(/Radar max_range:\s*([0-9.]+)\s*km/);
                if (covRangeMatch) covMaxRangeKm = parseFloat(covRangeMatch[1]);
            }
            if (!(covMaxRangeKm > 0)) {
                // Fallback: UI value or GT extent
                var covRadarRange = parseFloat(document.getElementById('radar-max-range').value);
                if (!(covRadarRange > 0)) covRadarRange = 800;
                var covGtMax = 0;
                for (var cgi = 0; cgi < gt.length; cgi++) {
                    var cgx = (gt[cgi].x || 0) / 1000 - sx;
                    var cgy = (gt[cgi].y || 0) / 1000 - sy;
                    var cgr = Math.sqrt(cgx * cgx + cgy * cgy);
                    if (cgr > covGtMax) covGtMax = cgr;
                }
                covMaxRangeKm = (covGtMax > 10) ? Math.min(covRadarRange, covGtMax * 1.3) : covRadarRange;
            }

            var covSElevRad  = covSElevDeg * Math.PI / 180;
            var covHalfElRad = (covBwDeg / 2) * Math.PI / 180;
            var covElBot     = covSElevRad - covHalfElRad;
            var covElTop     = covSElevRad + covHalfElRad;

            var covHasSector = covSectDeg > 0 && covSectDeg < 360;
            var covAzSpanDeg = covHasSector ? covSectDeg : covFovDeg;
            var covAzCenDeg  = covHasSector ? covSCenDeg : covBsightDeg;
            var covFull      = covAzSpanDeg >= 360;
            // UI bearing (0=North, CW) → math azimuth (0=East, CCW), same as Python backend
            var covAzCenRad  = (90 - covAzCenDeg) * Math.PI / 180;
            var covHalfAzRad = (covAzSpanDeg / 2) * Math.PI / 180;
            var covN         = 60;
            var covNpts      = covFull ? covN + 1 : covN;

            // Determine effective search max range
            var covEffectiveMaxKm = (covSearchMaxKm > 0 && covSearchMaxKm < covMaxRangeKm)
                ? covSearchMaxKm
                : covMaxRangeKm;

            // Build one arc at elevation el and range r → arrays {xa, ya, za}
            var covBuildArc = function(el, rangeKm) {
                var xa = [], ya = [], za = [];
                var cosEl = Math.cos(el), sinEl = Math.sin(el);
                for (var bi = 0; bi < covNpts; bi++) {
                    var baz = covFull
                        ? (2 * Math.PI * bi / covN)
                        : (covAzCenRad - covHalfAzRad + 2 * covHalfAzRad * bi / (covN - 1));
                    xa.push(rangeKm * cosEl * Math.cos(baz));
                    ya.push(rangeKm * cosEl * Math.sin(baz));
                    za.push(rangeKm * sinEl);
                }
                return { x: xa, y: ya, z: za };
            };

            // Build arcs at max range
            var arcBotOuter = covBuildArc(covElBot, covEffectiveMaxKm);
            var arcCenOuter = covBuildArc(covSElevRad, covEffectiveMaxKm);
            var arcTopOuter = covBuildArc(covElTop, covEffectiveMaxKm);

            // Build arcs at min range (if > 0)
            var arcBotInner = covMinRangeKm > 0 ? covBuildArc(covElBot, covMinRangeKm) : null;
            var arcCenInner = covMinRangeKm > 0 ? covBuildArc(covSElevRad, covMinRangeKm) : null;
            var arcTopInner = covMinRangeKm > 0 ? covBuildArc(covElTop, covMinRangeKm) : null;

            // Build wireframe: outer arcs + inner arcs (if min range > 0) + ribs
            var wx = [], wy = [], wz = [];

            // Outer center arc
            for (var wi = 0; wi < arcCenOuter.x.length; wi++) {
                wx.push(arcCenOuter.x[wi]); wy.push(arcCenOuter.y[wi]); wz.push(arcCenOuter.z[wi]);
            }
            wx.push(null); wy.push(null); wz.push(null);

            // Outer top arc
            for (var wi = 0; wi < arcTopOuter.x.length; wi++) {
                wx.push(arcTopOuter.x[wi]); wy.push(arcTopOuter.y[wi]); wz.push(arcTopOuter.z[wi]);
            }
            wx.push(null); wy.push(null); wz.push(null);

            // Outer bottom arc
            for (var wi = 0; wi < arcBotOuter.x.length; wi++) {
                wx.push(arcBotOuter.x[wi]); wy.push(arcBotOuter.y[wi]); wz.push(arcBotOuter.z[wi]);
            }
            wx.push(null); wy.push(null); wz.push(null);

            // Inner arcs (if min range > 0)
            if (arcCenInner) {
                for (var wi = 0; wi < arcCenInner.x.length; wi++) {
                    wx.push(arcCenInner.x[wi]); wy.push(arcCenInner.y[wi]); wz.push(arcCenInner.z[wi]);
                }
                wx.push(null); wy.push(null); wz.push(null);
                for (var wi = 0; wi < arcTopInner.x.length; wi++) {
                    wx.push(arcTopInner.x[wi]); wy.push(arcTopInner.y[wi]); wz.push(arcTopInner.z[wi]);
                }
                wx.push(null); wy.push(null); wz.push(null);
                for (var wi = 0; wi < arcBotInner.x.length; wi++) {
                    wx.push(arcBotInner.x[wi]); wy.push(arcBotInner.y[wi]); wz.push(arcBotInner.z[wi]);
                }
                wx.push(null); wy.push(null); wz.push(null);
            }

            // Radial ribs connecting inner to outer arcs
            var ribCount = covFull ? 8 : 2;
            for (var ri = 0; ri < ribCount; ri++) {
                var ribIdx = covFull
                    ? Math.round(arcTopOuter.x.length * ri / ribCount)
                    : (ri === 0 ? 0 : arcTopOuter.x.length - 1);
                if (ribIdx >= arcTopOuter.x.length) ribIdx = arcTopOuter.x.length - 1;

                if (arcTopInner) {
                    // Annulus: ribs from inner to outer arc
                    // Top elevation rib
                    wx.push(null, arcTopInner.x[ribIdx], arcTopOuter.x[ribIdx]);
                    wy.push(null, arcTopInner.y[ribIdx], arcTopOuter.y[ribIdx]);
                    wz.push(null, arcTopInner.z[ribIdx], arcTopOuter.z[ribIdx]);
                    // Bottom elevation rib
                    wx.push(null, arcBotInner.x[ribIdx], arcBotOuter.x[ribIdx]);
                    wy.push(null, arcBotInner.y[ribIdx], arcBotOuter.y[ribIdx]);
                    wz.push(null, arcBotInner.z[ribIdx], arcBotOuter.z[ribIdx]);
                } else {
                    // No inner arc: ribs from origin to outer arc
                    // Top elevation rib
                    wx.push(null, 0, arcTopOuter.x[ribIdx]);
                    wy.push(null, 0, arcTopOuter.y[ribIdx]);
                    wz.push(null, 0, arcTopOuter.z[ribIdx]);
                    // Bottom elevation rib
                    wx.push(null, 0, arcBotOuter.x[ribIdx]);
                    wy.push(null, 0, arcBotOuter.y[ribIdx]);
                    wz.push(null, 0, arcBotOuter.z[ribIdx]);
                }
            }

            // Sector lateral faces (for partial sector only)
            if (!covFull) {
                var lastIdx = arcBotOuter.x.length - 1;
                if (arcBotInner) {
                    // Annulus: lateral faces connect inner to outer arcs
                    // Left boundary: inner_bot[0] → outer_bot[0] → outer_top[0] → inner_top[0] → inner_bot[0]
                    wx.push(null, arcBotInner.x[0], arcBotOuter.x[0], arcTopOuter.x[0], arcTopInner.x[0], arcBotInner.x[0]);
                    wy.push(null, arcBotInner.y[0], arcBotOuter.y[0], arcTopOuter.y[0], arcTopInner.y[0], arcBotInner.y[0]);
                    wz.push(null, arcBotInner.z[0], arcBotOuter.z[0], arcTopOuter.z[0], arcTopInner.z[0], arcBotInner.z[0]);
                    // Right boundary: inner_bot[last] → outer_bot[last] → outer_top[last] → inner_top[last] → inner_bot[last]
                    wx.push(null, arcBotInner.x[lastIdx], arcBotOuter.x[lastIdx], arcTopOuter.x[lastIdx], arcTopInner.x[lastIdx], arcBotInner.x[lastIdx]);
                    wy.push(null, arcBotInner.y[lastIdx], arcBotOuter.y[lastIdx], arcTopOuter.y[lastIdx], arcTopInner.y[lastIdx], arcBotInner.y[lastIdx]);
                    wz.push(null, arcBotInner.z[lastIdx], arcBotOuter.z[lastIdx], arcTopOuter.z[lastIdx], arcTopInner.z[lastIdx], arcBotInner.z[lastIdx]);
                } else {
                    // No inner arc: lateral faces from origin to outer arcs
                    // Left boundary: origin → bot[0] → top[0] → origin
                    wx.push(null, 0, arcBotOuter.x[0], arcTopOuter.x[0], 0);
                    wy.push(null, 0, arcBotOuter.y[0], arcTopOuter.y[0], 0);
                    wz.push(null, 0, arcBotOuter.z[0], arcTopOuter.z[0], 0);
                    // Right boundary: origin → bot[last] → top[last] → origin
                    wx.push(null, 0, arcBotOuter.x[lastIdx], arcTopOuter.x[lastIdx], 0);
                    wy.push(null, 0, arcBotOuter.y[lastIdx], arcTopOuter.y[lastIdx], 0);
                    wz.push(null, 0, arcBotOuter.z[lastIdx], arcTopOuter.z[lastIdx], 0);
                }
            }

            // Build legend name with range band
            var covRangeName = (covMinRangeKm > 0)
                ? covMinRangeKm.toFixed(0) + '-' + covEffectiveMaxKm.toFixed(0) + 'km'
                : '0-' + covEffectiveMaxKm.toFixed(0) + 'km';
            var covElevName = 'Elev ' + covSElevDeg.toFixed(1) + '\u00b0 \xb1' + (covBwDeg / 2).toFixed(1) + '\u00b0';

            traces.push({
                type: 'scatter3d',
                mode: 'lines',
                x: wx, y: wy, z: wz,
                line: { color: '#00ddff', width: 2 },
                name: 'Search 覆域 ' + covRangeName + ' ' + covElevName,
                hoverinfo: 'skip',
                showlegend: true,
            });
        } catch (covErr) {
            console.error('[Search Coverage 3D] error:', covErr);
        }
    })();

    // Measurements: convert polar (range, azimuth, elevation) to cartesian relative to sensor
    // x/y: horizontal projection (range*cos(el)) to correct for slant range at high altitude
    // z: true detections use GT altitude lookup for clean visualization;
    //    clutter uses elevation-based z (near ground level)
    if (measurements.length > 0) {
        const dx = [], dy = [], dz = [], dtext = [];
        const cx = [], cy = [], cz = [], ctext = [];
        const step = measurements.length > 5000 ? Math.floor(measurements.length / 5000) : 1;

        // Debug: compare Truth vs Detection coordinates for first 3 non-clutter detections
        let dbgCount = 0;
        console.log(`[3D Chart Debug] sensor_x=${data.sensor_x} (type=${typeof data.sensor_x}), sensor_y=${data.sensor_y}, sx=${sx.toFixed(1)}km, sy=${sy.toFixed(1)}km`);
        // Cross-validate: extract C++ sensor position from stdout
        if (data.stdout) {
            const sensorMatch = data.stdout.match(/Sensor position: \(([^,]+)km, ([^)]+)km\)/);
            if (sensorMatch) {
                const cppSx = parseFloat(sensorMatch[1]) * 1000;  // convert km to m
                const cppSy = parseFloat(sensorMatch[2]) * 1000;
                const sxDiff = Math.abs(cppSx - (data.sensor_x || 0));
                console.log(`[3D Chart Debug] C++ sensor=(${sensorMatch[1]}km, ${sensorMatch[2]}km) = (${cppSx.toFixed(0)}m, ${cppSy.toFixed(0)}m)`);
                if (sxDiff > 100) {
                    console.warn(`[3D Chart Debug] MISMATCH: C++ sensor_x=${cppSx.toFixed(0)} vs JSON sensor_x=${data.sensor_x} diff=${sxDiff.toFixed(0)}m`);
                }
            }
        }
        if (gt.length > 0) {
            console.log(`[3D Chart Debug] gt[0]: x=${gt[0].x}, y=${gt[0].y}, z=${gt[0].z}, frame=${gt[0].frame}`);
            console.log(`[3D Chart Debug] gt[0] sensor-relative: x=${(gt[0].x/1000 - sx).toFixed(1)}km, y=${(gt[0].y/1000 - sy).toFixed(1)}km`);
        }

        for (let i = 0; i < measurements.length; i += step) {
            const m = measurements[i];
            const az = m.azimuth;
            const el = m.elevation || 0;
            const r_horiz_km = m.range * Math.cos(el) / 1000;
            const px = r_horiz_km * Math.cos(az);
            const py = r_horiz_km * Math.sin(az);

            // Check if clutter: true_target_id === -1 (new format) or is_clutter === 1 (legacy)
            const isClutter = (m.true_target_id === -1) || (m.is_clutter === 1 || m.is_clutter === true);

            // Debug log for first few true detections
            if (dbgCount < 3 && !isClutter) {
                const frameGt = gt.filter(r => r.frame === m.frame);
                if (frameGt.length > 0) {
                    const g = frameGt[0];
                    const truthX = g.x / 1000 - sx;
                    const truthY = g.y / 1000 - sy;
                    const off = Math.sqrt((truthX - px) ** 2 + (truthY - py) ** 2);
                    console.log(`[3D Chart Debug] frame=${m.frame} Truth=(${truthX.toFixed(1)}, ${truthY.toFixed(1)}) Det=(${px.toFixed(1)}, ${py.toFixed(1)}) offset=${off.toFixed(1)}km el=${(el*180/Math.PI).toFixed(2)}deg`);
                }
                dbgCount++;
            }
            const hover = `t=${m.time.toFixed(1)}s R=${m.range.toFixed(0)}m Az=${(az*180/Math.PI).toFixed(1)}° El=${(el*180/Math.PI).toFixed(1)}° SNR=${m.snr.toFixed(1)}dB`;
            if (isClutter) {
                const pz = m.range * Math.sin(el) / 1000;
                cx.push(px); cy.push(py); cz.push(pz); ctext.push('[False Alarm] ' + hover);
            } else {
                const pz = getDetectionAltitude(m);
                const targetId = m.true_target_id !== undefined ? ` Target#${m.true_target_id}` : '';
                dx.push(px); dy.push(py); dz.push(pz); dtext.push(`[Detection${targetId}] ` + hover);
            }
        }
        if (dx.length > 0) {
            traces.push({
                type: 'scatter3d', mode: 'markers',
                x: dx, y: dy, z: dz,
                marker: { size: 4, color: '#00ffff', opacity: 0.85, symbol: 'cross' },
                text: dtext, hoverinfo: 'text',
                legendgroup: 'detections', showlegend: false,
            });
            traces.push({
                type: 'scatter3d', mode: 'markers',
                x: [null], y: [null], z: [null],
                name: '✓ Target Detections',
                marker: { size: 10, color: '#00ffff', symbol: 'cross' },
                hoverinfo: 'skip',
                legendgroup: 'detections',
            });
        }
        if (cx.length > 0) {
            traces.push({
                type: 'scatter3d', mode: 'markers',
                x: cx, y: cy, z: cz,
                marker: { size: 2.5, color: 'rgba(255, 80, 80, 0.5)', symbol: 'x' },
                text: ctext, hoverinfo: 'text',
                legendgroup: 'falsealarms', showlegend: false,
            });
            traces.push({
                type: 'scatter3d', mode: 'markers',
                x: [null], y: [null], z: [null],
                name: '✗ False Alarms (Clutter)',
                marker: { size: 10, color: '#FF5050', symbol: 'x' },
                hoverinfo: 'skip',
                legendgroup: 'falsealarms',
            });
        }
    }

    // Ground truth lines (sensor-origin coordinates) - group by target_id
    const gtFiltered = gt.filter(r => r.time <= maxTrajectoryTime);
    const gtGroups = {};
    gtFiltered.forEach(r => {
        const id = r.target_id !== undefined ? r.target_id : 0;
        if (!gtGroups[id]) gtGroups[id] = [];
        gtGroups[id].push(r);
    });
    const gtColorPalette = [
        '#808080', '#888888', '#909090', '#787878',
        '#A0A0A0', '#707070', '#989898', '#686868',
    ];
    Object.entries(gtGroups).forEach(([id, rows], idx) => {
        traces.push({
            type: 'scatter3d',
            mode: 'lines',
            x: rows.map(r => r.x / 1000 - sx),
            y: rows.map(r => r.y / 1000 - sy),
            z: rows.map(r => (r.z != null) ? r.z / 1000 : getAltitude(r.time)),
            name: idx === 0 ? 'Truth' : `Truth ${id}`,
            line: { color: gtColorPalette[idx % gtColorPalette.length], width: 2 },
            legendgroup: 'truth',
            showlegend: idx === 0,
        });
    });

    function getTrackAltitude(row) {
        const frameGt = gtByFrame[row.frame];
        if (!frameGt || frameGt.length === 0) return getAltitude(row.time);
        let bestDist = Infinity, bestAlt = 0;
        for (const g of frameGt) {
            const dx = row.x - g.x, dy = row.y - g.y;
            const d = dx * dx + dy * dy;
            if (d < bestDist) {
                bestDist = d;
                bestAlt = (g.z != null) ? g.z / 1000 : getAltitude(g.time);
            }
        }
        return bestAlt;
    }

    // Group tracks by track_id, excluding Tentative tracks
    // Tentativeトラックを除外：state=1 (CONFIRMED) になったことがないトラックをフィルタ
    const trackGroups = {};
    const confirmedTrackIds = new Set();

    // First pass: identify tracks that ever became confirmed (state === 1)
    tracks.forEach(row => {
        if (row.state === 1) {
            confirmedTrackIds.add(row.track_id);
        }
    });

    // Second pass: group only confirmed tracks
    tracks.forEach(row => {
        const id = row.track_id;
        if (confirmedTrackIds.has(id)) {
            if (!trackGroups[id]) trackGroups[id] = [];
            trackGroups[id].push(row);
        }
    });

    // Color palette for tracks - unique color per track (避開cyan/gold)
    const trackColorPalette = [
        '#FF1493', '#00FF7F', '#9370DB', '#FF6347',
        '#32CD32', '#BA55D3', '#FF4500', '#20B2AA',
        '#FF69B4', '#3CB371', '#DA70D6', '#FF8C69',
    ];

    // Add each track (sensor-origin coordinates) - filter to flight duration
    let trackIdx = 0;
    Object.entries(trackGroups).forEach(([id, rows]) => {
        const filteredRows = rows.filter(r => r.time <= maxTrajectoryTime);
        if (filteredRows.length < 3) return;

        const color = trackColorPalette[trackIdx % trackColorPalette.length];
        trackIdx++;

        traces.push({
            type: 'scatter3d',
            mode: 'lines',
            x: filteredRows.map(r => r.x / 1000 - sx),
            y: filteredRows.map(r => r.y / 1000 - sy),
            z: filteredRows.map(r => (r.z != null) ? r.z / 1000 : getTrackAltitude(r)),
            name: `Track ${id}`,
            line: { color: color, width: 3 },
            showlegend: true,  // Always show tracks in legend
        });
    });

    // Calculate equal ranges for all axes to prevent distortion
    let xMin = Infinity, xMax = -Infinity;
    let yMin = Infinity, yMax = -Infinity;
    let zMin = Infinity, zMax = -Infinity;

    traces.forEach(trace => {
        if (trace.x && Array.isArray(trace.x)) {
            trace.x.forEach(val => {
                if (val != null && isFinite(val)) {
                    xMin = Math.min(xMin, val);
                    xMax = Math.max(xMax, val);
                }
            });
        }
        if (trace.y && Array.isArray(trace.y)) {
            trace.y.forEach(val => {
                if (val != null && isFinite(val)) {
                    yMin = Math.min(yMin, val);
                    yMax = Math.max(yMax, val);
                }
            });
        }
        if (trace.z && Array.isArray(trace.z)) {
            trace.z.forEach(val => {
                if (val != null && isFinite(val)) {
                    zMin = Math.min(zMin, val);
                    zMax = Math.max(zMax, val);
                }
            });
        }
    });

    const xRange = xMax - xMin, yRange = yMax - yMin, zRange = zMax - zMin;
    const maxRange = Math.max(xRange, yRange, zRange);
    const xCenter = (xMin + xMax) / 2, yCenter = (yMin + yMax) / 2, zCenter = (zMin + zMax) / 2;
    const axisRange = maxRange * 0.55; // 10% padding

    const layout = {
        scene: {
            xaxis: {
                title: 'X from Sensor (km)',
                backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa',
                range: [xCenter - axisRange, xCenter + axisRange]
            },
            yaxis: {
                title: 'Y from Sensor (km)',
                backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa',
                range: [yCenter - axisRange, yCenter + axisRange]
            },
            zaxis: {
                title: 'Altitude (km)',
                backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa',
                range: [zCenter - axisRange, zCenter + axisRange]
            },
            aspectmode: 'cube',  // 1:1:1 aspect ratio for true spatial representation
        },
        paper_bgcolor: '#16213e',
        plot_bgcolor: '#16213e',
        font: { color: '#e0e0e0' },
        margin: { l: 0, r: 0, t: 30, b: 0 },
        title: { text: 'Tracker Results vs Truth', font: { size: 14, color: '#e94560' } },
        legend: { x: 0.02, y: 0.98, bgcolor: 'rgba(0,0,0,0.5)' },
    };

    Plotly.newPlot('plot3d-tracking', traces, layout, { responsive: true });
}

function drawTimeline(data) {
    const gt = data.ground_truth || [];
    const tracks = data.tracks || [];
    if (!gt.length) return;

    // 1. GT: target_id ごとに birth/death を集計
    const gtTargets = {};
    gt.forEach(r => {
        const id = r.target_id !== undefined ? r.target_id : 0;
        if (!gtTargets[id]) gtTargets[id] = { birth: Infinity, death: -Infinity, rows: [] };
        const t = gtTargets[id];
        if (r.time < t.birth) t.birth = r.time;
        if (r.time > t.death) t.death = r.time;
        t.rows.push(r);
    });

    // 全目標の高度範囲を取得（グローバルスケーリング用）
    let globalMinAlt = Infinity;
    let globalMaxAlt = -Infinity;
    gt.forEach(r => {
        const alt = r.z / 1000; // km単位
        if (alt < globalMinAlt) globalMinAlt = alt;
        if (alt > globalMaxAlt) globalMaxAlt = alt;
    });
    const globalAltRange = globalMaxAlt - globalMinAlt || 1; // ゼロ除算防止

    // 2. Tracks: track_id ごとに init/confirm/end を集計
    const trackInfo = {};
    tracks.forEach(r => {
        const id = r.track_id;
        if (!trackInfo[id]) trackInfo[id] = { init: Infinity, end: -Infinity, confirmTime: null, rows: [] };
        const t = trackInfo[id];
        if (r.time < t.init) t.init = r.time;
        if (r.time > t.end) t.end = r.time;
        if (r.state === 1 && t.confirmTime === null) t.confirmTime = r.time;
        t.rows.push(r);
    });

    // 3. Track→Target マッチング（確認時の位置で最近傍GT割当）
    const targetIds = Object.keys(gtTargets).map(Number).sort((a, b) => a - b);
    const trackIds = Object.keys(trackInfo).map(Number).sort((a, b) => a - b);

    // GT を frame→targets インデックス化
    const gtByFrame = {};
    gt.forEach(r => {
        const f = r.frame;
        if (!gtByFrame[f]) gtByFrame[f] = [];
        gtByFrame[f].push(r);
    });

    // 各 track の確認時点で最近傍 GT target を検索
    const trackToTarget = {};
    trackIds.forEach(tid => {
        const info = trackInfo[tid];
        // 確認時 or 初期時のフレームを使用
        const matchTime = info.confirmTime !== null ? info.confirmTime : info.init;
        const matchRow = info.rows.find(r => r.time === matchTime) || info.rows[0];
        if (!matchRow) return;

        const frameGt = gtByFrame[matchRow.frame];
        if (!frameGt || frameGt.length === 0) return;

        let bestDist = Infinity, bestId = -1;
        for (const g of frameGt) {
            const dx = matchRow.x - g.x, dy = matchRow.y - g.y;
            const d = dx * dx + dy * dy;
            if (d < bestDist) { bestDist = d; bestId = g.target_id !== undefined ? g.target_id : 0; }
        }
        trackToTarget[tid] = bestId;
    });

    // 4. 各 target に対する track リストを構築
    const targetTracks = {};
    targetIds.forEach(id => { targetTracks[id] = []; });
    trackIds.forEach(tid => {
        const tgtId = trackToTarget[tid];
        if (tgtId !== undefined && targetTracks[tgtId]) {
            targetTracks[tgtId].push(tid);
        }
    });

    // 5. Plotly データ構築
    const shapes = [];
    const annotations = [];
    const traces = [];
    const yLabels = [];
    let yPos = 0;

    targetIds.forEach(targetId => {
        const tgt = gtTargets[targetId];
        const tids = targetTracks[targetId] || [];
        // Tentativeトラックを除外：confirmTimeがnullでないもののみ
        const confirmedTids = tids.filter(tid => trackInfo[tid].confirmTime !== null);
        const nTracks = Math.max(confirmedTids.length, 1); // 最低1行確保
        const yCenter = yPos + (nTracks - 1) / 2;

        // Y軸ラベル: ターゲット名を中央に配置
        yLabels.push({ pos: yCenter, label: `Target ${targetId}` });

        // GT ライフタイム (背景バー) — シンプルな背景
        shapes.push({
            type: 'rect', xref: 'x', yref: 'y',
            x0: tgt.birth, x1: tgt.death,
            y0: yPos - 0.35, y1: yPos + nTracks - 1 + 0.35,
            fillcolor: 'rgba(30, 190, 200, 0.12)',
            line: { color: 'rgba(30, 190, 200, 0.6)', width: 1.5 },
            layer: 'below',
        });

        // 高度プロファイル（ラインチャート）
        // 時系列でソート
        const sortedRows = tgt.rows.slice().sort((a, b) => a.time - b.time);
        const altTimes = sortedRows.map(r => r.time);
        const altValues = sortedRows.map(r => r.z / 1000); // km単位

        // 行の範囲内に高度をマッピング（グローバルスケール使用）
        const barBottom = yPos - 0.35;  // バーの下端
        const barTop = yPos + nTracks - 0.65;  // バーの上端
        const margin = 0.05;  // 上下マージン（はみ出し防止）
        const lineBottom = barBottom + margin;
        const lineTop = barTop - margin;
        const lineHeight = lineTop - lineBottom;

        const altY = altValues.map(alt => {
            // グローバル範囲で正規化（全目標で同じスケール）
            const ratio = (alt - globalMinAlt) / globalAltRange;
            // 低高度=下（大きいY）、高高度=上（小さいY）
            return lineBottom + (1 - ratio) * lineHeight;
        });

        // 高度ラインチャート（凡例なし、背景と同色系）
        traces.push({
            type: 'scatter',
            mode: 'lines',
            x: altTimes,
            y: altY,
            name: `Target ${targetId} Altitude`,
            text: altValues.map(alt => `${alt.toFixed(1)} km`),
            hovertemplate: 'Time: %{x:.2f}s<br>Altitude: %{text}<extra></extra>',
            line: { color: 'rgba(100, 200, 220, 0.4)', width: 1.5 }, // 薄い青緑、細め
            showlegend: false,
        });

        // このターゲットに関連するトラック — 各トラックに個別サブ行
        // Tentative（仮確定）トラックは表示しない（confirmedTidsでフィルタ済み）
        confirmedTids.forEach((tid, idx) => {
            const info = trackInfo[tid];
            const ty = yPos + idx;  // サブ行のY位置

            // Tentativeフェーズは非表示（confirmedのみ表示）

            // Confirmed phase — 探知/未探知理由/着弾後で色分け
            // miss_reason: 0=探知, 1=覆域外, 2=ビームリソース不足, 3=ビーム照射未探知
            if (info.confirmTime !== null) {
                const deathTime = tgt.death;

                const confRows = info.rows
                    .filter(r => r.time >= info.confirmTime)
                    .sort((a, b) => a.time - b.time);

                if (confRows.length > 0) {
                    const getState = (r) => {
                        if (r.time > deathTime) return 'post';
                        if (r.misses === 0) return 'det';
                        const mr = r.miss_reason;
                        if (mr === 1) return 'out_fov';
                        if (mr === 2) return 'no_beam';
                        return 'beam_miss';
                    };

                    const colorMap = {
                        det:       'rgba(0, 210, 90, 0.80)',    // 探知: 緑
                        beam_miss: 'rgba(160, 60, 220, 0.80)',  // ビーム照射未探知: 紫
                        no_beam:   'rgba(30, 150, 255, 0.80)',  // ビームリソース不足: 青
                        out_fov:   'rgba(210, 30, 30, 0.80)',   // 覆域外: 赤
                        post:      'rgba(90, 90, 90, 0.65)',    // 着弾後: 濃グレー
                    };

                    let segStart = confRows[0].time;
                    let segState = getState(confRows[0]);

                    for (let i = 1; i <= confRows.length; i++) {
                        const isLast = (i === confRows.length);
                        const curState = isLast ? null : getState(confRows[i]);

                        if (curState !== segState || isLast) {
                            const segEnd = isLast ? info.end : confRows[i].time;
                            shapes.push({
                                type: 'rect', xref: 'x', yref: 'y',
                                x0: segStart, x1: segEnd, y0: ty - 0.15, y1: ty + 0.15,
                                fillcolor: colorMap[segState],
                                line: { width: 0 },
                            });
                            if (!isLast) {
                                segStart = confRows[i].time;
                                segState = curState;
                            }
                        }
                    }
                }
            }

        });

        yPos += nTracks;
    });

    // バー色分けの凡例用ダミートレース（shapesは凡例に出ないため）
    // Tentativeは非表示のため凡例から除外
    const barLegend = [
        { name: 'Detected',        color: 'rgba(0, 210, 90, 0.80)' },
        { name: 'Beam Miss',       color: 'rgba(160, 60, 220, 0.80)' },
        { name: 'No Beam',         color: 'rgba(30, 150, 255, 0.80)' },
        { name: 'Out of FOV',      color: 'rgba(210, 30, 30, 0.80)' },
        { name: 'Post-Impact',     color: 'rgba(90, 90, 90, 0.65)' },
        { name: 'GT Lifetime',     color: 'rgba(30, 190, 200, 0.40)' },
    ];
    barLegend.forEach(item => {
        traces.push({
            type: 'scatter', mode: 'markers',
            x: [null], y: [null],
            name: item.name,
            marker: { symbol: 'square', size: 10, color: item.color, line: { color: item.color, width: 1 } },
            showlegend: true,
        });
    });

    // 行数に基づく高さ計算（1行あたり40px、最低でもコンテナ高さ）
    const rowHeight = 40;
    const minHeight = 300;
    const computedHeight = Math.max(minHeight, yPos * rowHeight + 80);
    const container = document.getElementById('plot-timeline');
    container.style.height = computedHeight + 'px';

    // レイアウト
    const layout = {
        paper_bgcolor: '#0f3460',
        plot_bgcolor: '#16213e',
        font: { color: '#e0e0e0' },
        margin: { l: 80, r: 20, t: 8, b: 40 },
        xaxis: {
            title: 'Time [s]', gridcolor: '#1a1a2e', zerolinecolor: '#333',
            color: '#aaa',
        },
        yaxis: {
            tickvals: yLabels.map(l => l.pos),
            ticktext: yLabels.map(l => l.label),
            gridcolor: '#1a1a2e',
            color: '#aaa',
            range: [yPos - 0.5, -0.5],
        },
        legend: { x: 0, y: 1, orientation: 'h', bgcolor: 'rgba(0,0,0,0.3)', font: { size: 11 }, xanchor: 'left', yanchor: 'bottom' },
        shapes: shapes,
        height: computedHeight,
    };

    Plotly.newPlot('plot-timeline', traces, layout, { responsive: true });
}

async function displayEvaluation(data) {
    // Update small eval-grid in control panel
    const container = document.getElementById('eval-results');
    const summary = data.eval_summary || {};
    let html = '';

    // Show aggregated results if available
    if (summary.num_runs && summary.num_runs > 1) {
        const fmtAgg = (d) => d ? `${d.mean.toFixed(1)}±${d.std.toFixed(1)}` : '-';
        const fmtAggS = (d) => d ? `${d.mean.toFixed(2)}±${d.std.toFixed(2)}` : '-';
        const quickMetrics = [
            ['Pos RMSE', fmtAgg(summary['agg_Position RMSE']), 'm'],
            ['OSPA', fmtAgg(summary['agg_OSPA Distance']), 'm'],
            ['F1', fmtAgg(summary['agg_F1 Score']), '%'],
            ['Wall-clock', fmtAggS(summary['agg_Wall-clock']), 's'],
            ['Runs', summary.num_runs, ''],
        ];
        quickMetrics.forEach(([label, value, unit]) => {
            html += `<div class="eval-item"><span class="label">${label}:</span> <span class="value">${value} ${unit}</span></div>`;
        });
    } else {
        const quickMetrics = [
            ['Position RMSE', summary['Position RMSE'] != null ? summary['Position RMSE'].toFixed(1) : '-', 'm'],
            ['OSPA Distance', summary['Mean OSPA'] != null ? summary['Mean OSPA'].toFixed(1) : '-', 'm'],
            ['Tracks Created', Object.keys(groupBy(data.tracks, 'track_id')).length, ''],
            ['GT Frames', data.ground_truth.length, ''],
        ];
        quickMetrics.forEach(([label, value, unit]) => {
            const v = typeof value === 'number' ? value.toFixed(1) : value;
            html += `<div class="eval-item"><span class="label">${label}:</span> <span class="value">${v} ${unit}</span></div>`;
        });
    }
    container.innerHTML = html;

    // Build comprehensive Evaluation tab using summary from backend
    const s = summary;  // All metrics parsed from full stdout on backend
    const numTracks = Object.keys(groupBy(data.tracks, 'track_id')).length;
    const ei = (label, value, unit, tooltip) => {
        const v = (value != null && value !== '' && value !== undefined) ? value : '-';
        const tip = tooltip ? ` title="${tooltip}"` : '';
        return `<div class="eval-full-item"><span class="label"${tip}>${label}</span><span class="value">${v}${unit ? ' ' + unit : ''}</span></div>`;
    };
    const fmt = (v, d) => v != null ? v.toFixed(d != null ? d : 2) : null;

    let e = '';

    // Aggregated results (multi-run)
    if (s.num_runs && s.num_runs > 1) {
        const ae = (label, key, unit, tooltip) => {
            const d = s[key];
            if (d && d.mean !== undefined) {
                return ei(label, `${d.mean.toFixed(1)} \u00b1 ${d.std.toFixed(1)}`, unit, tooltip);
            }
            return '';
        };
        e += `<div class="eval-section-title" style="color: #4ecdc4;">Aggregated Results (${s.num_runs} runs)</div><div class="eval-full-grid">`;
        e += ae('Position RMSE', 'agg_Position RMSE', 'm', 'Mean \u00b1 StdDev of position RMSE across all runs');
        e += ae('Velocity RMSE', 'agg_Velocity RMSE', 'm/s', 'Mean \u00b1 StdDev of velocity RMSE across all runs');
        e += ae('OSPA Distance', 'agg_OSPA Distance', 'm', 'Mean \u00b1 StdDev of OSPA distance across all runs');
        e += ae('Precision', 'agg_Precision', '%', 'Mean \u00b1 StdDev of precision across all runs');
        e += ae('Recall', 'agg_Recall', '%', 'Mean \u00b1 StdDev of recall across all runs');
        e += ae('F1 Score', 'agg_F1 Score', '%', 'Mean \u00b1 StdDev of F1 score across all runs');
        e += ae('Wall-clock', 'agg_Wall-clock', 's', 'Mean \u00b1 StdDev of total wall-clock time per run');
        e += ae('Avg Frame', 'agg_Avg frame', 'ms', 'Mean \u00b1 StdDev of average GPU frame time per run');
        e += '</div>';
    }

    e += '<div class="eval-section-title">Accuracy</div><div class="eval-full-grid">';
    e += ei('Position RMSE', fmt(s['Position RMSE']), 'm', 'Root Mean Square Error of position (x,y) between tracks and ground truth');
    e += ei('Position MAE', fmt(s['Position MAE']), 'm', 'Mean Absolute Error of position between tracks and ground truth');
    e += ei('Velocity RMSE', fmt(s['Velocity RMSE']), 'm/s', 'Root Mean Square Error of velocity (vx,vy) between tracks and ground truth');
    e += ei('Velocity MAE', fmt(s['Velocity MAE']), 'm/s', 'Mean Absolute Error of velocity between tracks and ground truth');
    e += ei('Mean OSPA', fmt(s['Mean OSPA']), 'm', 'Optimal Sub-Pattern Assignment distance. Combines position error, missed targets, and false tracks into a single metric');
    e += '</div>';

    e += '<div class="eval-section-title">Detection</div><div class="eval-full-grid">';
    e += ei('True Positives', fmt(s['True Positives'], 0), '', 'Number of frames where a confirmed track is correctly matched to a ground truth target');
    e += ei('False Positives', fmt(s['False Positives'], 0), '', 'Number of confirmed tracks not matched to any ground truth (false alarms)');
    e += ei('False Negatives', fmt(s['False Negatives'], 0), '', 'Number of ground truth targets without a matching confirmed track (missed detections)');
    e += ei('Precision', fmt(s['Precision'], 4), '%', 'TP / (TP + FP). Fraction of confirmed tracks that are real targets. Higher = fewer false tracks');
    e += ei('Recall', fmt(s['Recall'], 4), '%', 'TP / (TP + FN). Fraction of real targets that are tracked. Higher = fewer missed targets');
    e += ei('F1 Score', fmt(s['F1 Score'], 4), '%', 'Harmonic mean of Precision and Recall. Overall tracking performance metric (0-100%)');
    e += '</div>';

    e += '<div class="eval-section-title">Track Quality</div><div class="eval-full-grid">';
    e += ei('Total Tracks', numTracks, '', 'Total number of distinct tracks created during the simulation');
    e += ei('Avg Duration', fmt(s['Avg Track Duration']), 's', 'Average lifetime of tracks');
    e += ei('Confirm Rate', fmt(s['Confirmation Rate']), '%', 'Fraction of created tracks that reached confirmed state');
    e += ei('False Track Rate', fmt(s['False Track Rate']), '%', 'Fraction of confirmed tracks not associated with any real target');
    e += ei('Track Purity', fmt(s['Track Purity']), '%', 'Average fraction of updates from the dominant true target per track (1.0 = no ID switches)');
    e += ei('Mostly Tracked', fmt(s['Mostly Tracked (MT)'], 0), '', 'Targets tracked for >80% of their lifetime');
    e += ei('Partially Tracked', fmt(s['Partially Tracked (PT)'], 0), '', 'Targets tracked for 20-80% of their lifetime');
    e += ei('Mostly Lost', fmt(s['Mostly Lost (ML)'], 0), '', 'Targets tracked for <20% of their lifetime');
    e += '</div>';

    e += '<div class="eval-section-title">Data Statistics</div><div class="eval-full-grid">';
    e += ei('Total Frames', fmt(s['Total Frames'], 0), '', 'Total number of simulation time steps');
    e += ei('GT Frames', data.ground_truth.length, '', 'Total ground truth data points (targets x frames)');
    e += ei('Measurements', (data.measurements || []).length, '', 'Total radar measurements (detections + clutter)');
    e += ei('Avg GT/Frame', fmt(s['Avg GT Targets'], 0), '', 'Average number of active ground truth targets per frame');
    e += ei('Avg Tracks/Frame', fmt(s['Avg Tracks'], 0), '', 'Average number of active tracks per frame');
    e += '</div>';

    // Performance section
    const wallMs = s['Wall-clock time'];
    const gpuTotal = s['GPU total'];
    const gpuAvg = s['GPU avg/frame'];
    const gpuMin = s['GPU min/frame'];
    const gpuMax = s['GPU max/frame'];
    const rtFactor = s['Realtime factor'];
    const predictMs = s['Predict total'];
    const assocMs = s['Association total'];
    const updateMs = s['Update total'];

    e += '<div class="eval-section-title">Performance</div><div class="eval-full-grid">';
    e += ei('Wall-clock', wallMs != null ? (wallMs / 1000).toFixed(2) : null, 's', 'Total elapsed wall-clock time for the simulation run');
    e += ei('Realtime Factor', rtFactor != null ? rtFactor.toFixed(1) + 'x' : null, '', 'Simulation speed relative to realtime. >1x means faster than realtime');
    e += ei('GPU Total', gpuTotal != null ? gpuTotal.toFixed(1) : null, 'ms', 'Total GPU processing time across all frames (predict + associate + update)');
    e += ei('GPU Avg/Frame', gpuAvg != null ? gpuAvg.toFixed(2) : null, 'ms', 'Average GPU processing time per frame');
    e += ei('GPU Min/Frame', gpuMin != null ? gpuMin.toFixed(2) : null, 'ms', 'Minimum GPU processing time for a single frame');
    e += ei('GPU Max/Frame', gpuMax != null ? gpuMax.toFixed(2) : null, 'ms', 'Maximum GPU processing time for a single frame');
    e += ei('Predict', predictMs != null ? predictMs.toFixed(1) : null, 'ms', 'Total time for UKF prediction step (sigma points + state propagation)');
    e += ei('Association', assocMs != null ? assocMs.toFixed(1) : null, 'ms', 'Total time for measurement-to-track data association (gating + assignment)');
    e += ei('Update', updateMs != null ? updateMs.toFixed(1) : null, 'ms', 'Total time for UKF update step (Kalman gain + state/covariance update)');
    e += '</div>';

    // Chart containers
    e += '<div class="eval-charts-grid">';
    e += '<div class="eval-chart" id="eval-chart-pos"></div>';
    e += '<div class="eval-chart" id="eval-chart-ospa"></div>';
    e += '<div class="eval-chart" id="eval-chart-tracks"></div>';
    e += '<div class="eval-chart" id="eval-chart-detect"></div>';
    e += '<div class="eval-chart" id="eval-chart-perf"></div>';
    e += '<div class="eval-chart" id="eval-chart-beam"></div>';
    e += '<div class="eval-chart" id="eval-chart-imm"></div>';
    e += '<div class="eval-chart" id="eval-chart-snr-density"></div>';
    e += '<div class="eval-chart" id="eval-chart-det-range"></div>';
    e += '</div>';

    document.getElementById('eval-tab-content').innerHTML = e;

    // Draw time-series charts from per-frame evaluation data
    const evalRows = data.evaluation || [];
    const resultsRows = data.results || [];
    if (evalRows.length > 0) {
        await drawEvalCharts(evalRows, resultsRows);
    }

    // IMM Model Probabilities Chart
    const trackRows = data.tracks || [];
    if (trackRows.length > 0) {
        await drawIMMChart(trackRows);
    }

    // Detection Probability Density Diagram
    const meas = data.measurements || [];
    if (meas.length > 0) {
        await drawDetectionDensityCharts(meas, data.ground_truth || [], data.sensor_x || 0, data.sensor_y || 0);
    }

    // Enable tabs (don't auto-switch here; runTracker controls which tab to show)
    enableVizTab('evaluation');
}

function displayConsole(data) {
    const container = document.getElementById('console-output');
    if (!data || !data.stdout) {
        container.innerHTML = '<div style="color: #7ec8e3; text-align: center; padding: 40px 20px;">No console output available</div>';
        return;
    }

    // Parse stdout to extract key sections and highlight important info
    const stdout = data.stdout;
    let html = '';

    // Add header with summary
    html += '<div style="color: #4ecdc4; font-weight: bold; font-size: 14px; margin-bottom: 12px; border-bottom: 1px solid #1e3a5f; padding-bottom: 8px;">Console Output</div>';

    // Extract and highlight key configuration sections
    const sections = [
        { name: 'Scenario Configuration', pattern: /Scenario:.*?(?=\n\n|\nRadar|\nSensor|\nTracker|$)/s, color: '#e94560' },
        { name: 'Radar Parameters', pattern: /Radar.*?parameters:.*?(?=\n\n|\nSensor|\nTracker|$)/s, color: '#4ecdc4' },
        { name: 'Sensor Configuration', pattern: /Sensor.*?(?:position|configuration):.*?(?=\n\n|\nRadar|\nTracker|$)/s, color: '#f38181' },
        { name: 'Tracker Parameters', pattern: /Tracker parameters:.*?(?=\n\n|\nRunning|$)/s, color: '#95e1d3' },
        { name: 'Beam Steering', pattern: /Beam steering:.*?(?=\n|$)/m, color: '#ffd700' },
        { name: 'Search Range', pattern: /Search range:.*?(?=\n|$)/m, color: '#ffa500' }
    ];

    let extractedSections = [];
    let remainingText = stdout;

    sections.forEach(sec => {
        const match = stdout.match(sec.pattern);
        if (match) {
            extractedSections.push({
                name: sec.name,
                content: match[0],
                color: sec.color
            });
        }
    });

    // Display extracted sections with highlighting
    if (extractedSections.length > 0) {
        html += '<div style="margin-bottom: 16px;">';
        extractedSections.forEach(sec => {
            html += `<div style="margin-bottom: 12px;">`;
            html += `<div style="color: ${sec.color}; font-weight: bold; margin-bottom: 4px;">▸ ${sec.name}</div>`;
            html += `<div style="color: #e0e0e0; margin-left: 12px; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 11px;">${escapeHtml(sec.content)}</div>`;
            html += `</div>`;
        });
        html += '</div>';
        html += '<div style="border-top: 1px solid #1e3a5f; margin: 16px 0;"></div>';
    }

    // Full raw output (collapsible)
    html += '<div style="margin-bottom: 8px;">';
    html += '<div style="color: #7ec8e3; font-weight: bold; cursor: pointer; user-select: none;" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === \'none\' ? \'block\' : \'none\'">▾ Full Console Output (click to toggle)</div>';
    html += `<div style="color: #c0c0c0; margin-top: 8px; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 10px; max-height: 400px; overflow-y: auto; background: #050f1a; padding: 12px; border-radius: 4px; border: 1px solid #0f2744;">${escapeHtml(stdout)}</div>`;
    html += '</div>';

    container.innerHTML = html;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

async function drawIMMChart(trackRows) {
    // Filter to confirmed tracks and extract IMM model probabilities
    const confirmedTracks = trackRows.filter(r => parseInt(r.state) === 1);
    if (confirmedTracks.length === 0) return;

    // Group by time to get average probabilities across all tracks
    const timeMap = {};
    confirmedTracks.forEach(r => {
        const t = parseFloat(r.time);
        if (!timeMap[t]) {
            timeMap[t] = { cv: [], ballistic: [], ct: [] };
        }
        timeMap[t].cv.push(parseFloat(r.model_prob_cv) || 0);
        timeMap[t].ballistic.push(parseFloat(r.model_prob_ballistic) || 0);
        timeMap[t].ct.push(parseFloat(r.model_prob_ct) || 0);
    });

    // Calculate average probabilities for each time
    const times = Object.keys(timeMap).map(parseFloat).sort((a,b) => a - b);
    const avgCV = times.map(t => {
        const vals = timeMap[t].cv;
        return vals.reduce((a,b) => a + b, 0) / vals.length;
    });
    const avgBallistic = times.map(t => {
        const vals = timeMap[t].ballistic;
        return vals.reduce((a,b) => a + b, 0) / vals.length;
    });
    const avgCT = times.map(t => {
        const vals = timeMap[t].ct;
        return vals.reduce((a,b) => a + b, 0) / vals.length;
    });

    const darkLayout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(15,52,96,0.5)',
        font: { color: '#aaa', size: 9 },
        margin: { l: 40, r: 20, t: 30, b: 30 },
        xaxis: { title: 'Time [s]', gridcolor: '#1e3a5f', showgrid: true },
        yaxis: { title: 'Model Probability', gridcolor: '#1e3a5f', showgrid: true, range: [0, 1] },
        hovermode: 'x unified',
        showlegend: true,
        legend: { x: 1, xanchor: 'right', y: 1, bgcolor: 'rgba(0,0,0,0.3)' },
    };

    Plotly.newPlot('eval-chart-imm', [
        {
            x: times, y: avgCV,
            type: 'scatter', mode: 'lines', name: 'CV (Constant Velocity)',
            line: { color: '#00ff00', width: 2 },
            fill: 'tozeroy', fillcolor: 'rgba(0,255,0,0.2)',
        },
        {
            x: times, y: avgBallistic,
            type: 'scatter', mode: 'lines', name: 'Ballistic',
            line: { color: '#ff9900', width: 2 },
            fill: 'tozeroy', fillcolor: 'rgba(255,153,0,0.2)',
        },
        {
            x: times, y: avgCT,
            type: 'scatter', mode: 'lines', name: 'CT (Coordinated Turn)',
            line: { color: '#ff00ff', width: 2 },
            fill: 'tozeroy', fillcolor: 'rgba(255,0,255,0.2)',
        },
    ], {
        ...darkLayout,
        title: 'IMM Model Probabilities (Avg across tracks)',
    }, { responsive: true, displayModeBar: false });
}

async function drawEvalCharts(rows, resultsRows) {
    const times = rows.map(r => parseFloat(r.timestamp));
    const darkLayout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(15,52,96,0.5)',
        font: { color: '#aaa', size: 9 },
        margin: { l: 45, r: 8, t: 24, b: 28 },
        xaxis: { gridcolor: '#333', title: { text: 'Time (s)', font: { size: 9 } } },
        yaxis: { gridcolor: '#333' },
        legend: { x: 0.01, y: 0.99, bgcolor: 'rgba(0,0,0,0.4)', font: { size: 8 } },
    };
    const cfg = { responsive: true, displayModeBar: false };
    const yieldToUI = () => new Promise(resolve => setTimeout(resolve, 0));

    // Position Error
    Plotly.newPlot('eval-chart-pos', [{
        x: times, y: rows.map(r => parseFloat(r.avg_position_error)),
        type: 'scatter', mode: 'lines', name: 'Pos Error',
        line: { color: '#e94560', width: 1.5 },
    }], { ...darkLayout, title: { text: 'Position Error (m)', font: { size: 10, color: '#e94560' } },
        yaxis: { ...darkLayout.yaxis, title: { text: 'm', font: { size: 9 } } }
    }, cfg);
    await yieldToUI();

    // OSPA Distance
    Plotly.newPlot('eval-chart-ospa', [{
        x: times, y: rows.map(r => parseFloat(r.ospa_distance)),
        type: 'scatter', mode: 'lines', name: 'OSPA',
        line: { color: '#7ec8e3', width: 1.5 },
    }], { ...darkLayout, title: { text: 'OSPA Distance (m)', font: { size: 10, color: '#7ec8e3' } },
        yaxis: { ...darkLayout.yaxis, title: { text: 'm', font: { size: 9 } } }
    }, cfg);
    await yieldToUI();

    // Track Count vs Truth
    Plotly.newPlot('eval-chart-tracks', [
        { x: times, y: rows.map(r => parseInt(r.num_ground_truth)), type: 'scatter', mode: 'lines',
          name: 'GT', line: { color: '#ffd700', width: 1.5 } },
        { x: times, y: rows.map(r => parseInt(r.num_tracks)), type: 'scatter', mode: 'lines',
          name: 'Tracks', line: { color: '#00ff88', width: 1.5 } },
        { x: times, y: rows.map(r => parseInt(r.num_confirmed)), type: 'scatter', mode: 'lines',
          name: 'Confirmed', line: { color: '#00ff88', width: 1, dash: 'dot' } },
    ], { ...darkLayout, title: { text: 'Tracks vs Truth', font: { size: 10, color: '#ffd700' } },
        yaxis: { ...darkLayout.yaxis, title: { text: 'Count', font: { size: 9 } } }
    }, cfg);
    await yieldToUI();

    // Detection: TP / FP / FN
    Plotly.newPlot('eval-chart-detect', [
        { x: times, y: rows.map(r => parseInt(r.true_positives)), type: 'scatter', mode: 'lines',
          name: 'TP', line: { color: '#00ff88', width: 1.5 } },
        { x: times, y: rows.map(r => parseInt(r.false_positives)), type: 'scatter', mode: 'lines',
          name: 'FP', line: { color: '#ff6b6b', width: 1.5 } },
        { x: times, y: rows.map(r => parseInt(r.false_negatives)), type: 'scatter', mode: 'lines',
          name: 'FN', line: { color: '#ffa500', width: 1.5 } },
    ], { ...darkLayout, title: { text: 'Detection Metrics', font: { size: 10, color: '#00ff88' } },
        yaxis: { ...darkLayout.yaxis, title: { text: 'Count', font: { size: 9 } } }
    }, cfg);
    await yieldToUI();

    // Processing Time chart (from results.csv)
    if (resultsRows && resultsRows.length > 0) {
        const perfTimes = resultsRows.map(r => parseFloat(r.time));
        const perfMs = resultsRows.map(r => parseFloat(r.processing_time_ms));
        Plotly.newPlot('eval-chart-perf', [{
            x: perfTimes, y: perfMs,
            type: 'scatter', mode: 'lines', name: 'Frame Time',
            line: { color: '#c084fc', width: 1.5 },
        }], { ...darkLayout, title: { text: 'Processing Time (ms/frame)', font: { size: 10, color: '#c084fc' } },
            yaxis: { ...darkLayout.yaxis, title: { text: 'ms', font: { size: 9 } } }
        }, cfg);

        // Beam Resource Saturation chart
        const beamTrack = resultsRows.map(r => parseInt(r.beam_track) || 0);
        const beamSearch = resultsRows.map(r => parseInt(r.beam_search) || 0);
        const beamDemand = resultsRows.map(r => parseInt(r.beam_demand) || 0);
        const hasBeamData = beamTrack.some(v => v > 0) || beamSearch.some(v => v > 0) || beamDemand.some(v => v > 0);
        if (hasBeamData) {
            const beamBudget = beamTrack.map((t, i) => t + beamSearch[i]);
            Plotly.newPlot('eval-chart-beam', [
                { x: perfTimes, y: beamDemand, type: 'scatter', mode: 'lines',
                  name: 'Demand', line: { color: '#ff6b6b', width: 1.5, dash: 'dot' } },
                { x: perfTimes, y: beamTrack, type: 'scatter', mode: 'lines',
                  name: 'Track Beams', line: { color: '#00ff88', width: 1.5 },
                  fill: 'tozeroy', fillcolor: 'rgba(0, 255, 136, 0.15)' },
                { x: perfTimes, y: beamBudget, type: 'scatter', mode: 'lines',
                  name: 'Total (Track+Search)', line: { color: '#7ec8e3', width: 1.5 },
                  fill: 'tonexty', fillcolor: 'rgba(126, 200, 227, 0.15)' },
            ], { ...darkLayout, title: { text: 'Beam Resource Allocation', font: { size: 10, color: '#7ec8e3' } },
                yaxis: { ...darkLayout.yaxis, title: { text: 'Beams', font: { size: 9 } } }
            }, cfg);
        }
    }
}

async function drawDetectionDensityCharts(measurements, groundTruth, sensorX, sensorY) {
    const yieldToUI = () => new Promise(resolve => setTimeout(resolve, 0));
    const darkLayout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(15,52,96,0.5)',
        font: { color: '#aaa', size: 9 },
        margin: { l: 48, r: 40, t: 28, b: 32 },
        legend: { x: 0.01, y: 0.99, bgcolor: 'rgba(0,0,0,0.4)', font: { size: 8 } },
    };
    const cfg = { responsive: true, displayModeBar: false };

    // Separate target detections from clutter (false alarms)
    // New format: true_target_id === -1 means clutter, >= 0 means target detection
    // Legacy format: is_clutter === 1 means clutter
    const isClutterFn = m => (m.true_target_id === -1) || (m.is_clutter === 1 || m.is_clutter === true);
    const trueDet = measurements.filter(m => !isClutterFn(m));
    const clutter  = measurements.filter(m =>  isClutterFn(m));

    console.log(`[Detection Density] Total: ${measurements.length}, Targets: ${trueDet.length}, Clutter: ${clutter.length}`);

    // ── Chart 1: SNR Probability Density ────────────────────────────────────
    // Shows the SNR distribution under H0 (clutter/false alarm) and H1 (target) hypothesis.
    // This is the evaluation version with clear separation for assessment.
    const snrBinSize = 2;
    Plotly.newPlot('eval-chart-snr-density', [
        {
            x: trueDet.map(m => m.snr),
            type: 'histogram', histnorm: 'probability density',
            name: `✓ Target Detections (${trueDet.length})`,
            marker: { color: 'rgba(0,255,100,0.7)', line: { color: '#00ff64', width: 1 } },
            xbins: { start: -10, end: 80, size: snrBinSize },
            opacity: 0.9,
        },
        {
            x: clutter.map(m => m.snr),
            type: 'histogram', histnorm: 'probability density',
            name: `✗ False Alarms (${clutter.length})`,
            marker: { color: 'rgba(255,50,50,0.6)', line: { color: '#ff3232', width: 1 } },
            xbins: { start: -10, end: 80, size: snrBinSize },
            opacity: 0.9,
        },
    ], {
        ...darkLayout,
        barmode: 'overlay',
        title: { text: 'SNR Probability Density — Target vs. Clutter Separation', font: { size: 10, color: '#ffd700' } },
        xaxis: { gridcolor: '#333', title: { text: 'SNR (dB)', font: { size: 9 } } },
        yaxis: { gridcolor: '#333', title: { text: 'Probability Density', font: { size: 9 } } },
        annotations: [{
            x: 0.5, y: 1.02, xref: 'paper', yref: 'paper',
            text: 'H₁: Target Hypothesis (Green) | H₀: Clutter Hypothesis (Red)',
            showarrow: false, font: { size: 8, color: '#999' },
            xanchor: 'center'
        }]
    }, cfg);
    await yieldToUI();

    // ── Chart 2: Detection Probability vs. Range ─────────────────────────────
    // P(D) per range bin = detected / ground-truth targets in that bin
    const N_BINS = 20;
    const gtRangesKm = groundTruth.map(g => {
        const dx = (g.x || 0) - sensorX;
        const dy = (g.y || 0) - sensorY;
        const dz = (g.z || 0);
        return Math.sqrt(dx * dx + dy * dy + dz * dz) / 1000;
    }).filter(r => isFinite(r) && r >= 0);

    const detRangesKm = trueDet.map(m => m.range / 1000);
    const clutterRangesKm = clutter.map(m => m.range / 1000);

    const allRanges = [...gtRangesKm, ...detRangesKm, ...clutterRangesKm];
    const maxRange = allRanges.length > 0 ? Math.max(...allRanges) : 1;
    const binSize = maxRange / N_BINS;

    const gtCounts  = new Array(N_BINS).fill(0);
    const detCounts = new Array(N_BINS).fill(0);
    const clutCounts = new Array(N_BINS).fill(0);

    gtRangesKm.forEach(r => {
        const b = Math.min(Math.floor(r / binSize), N_BINS - 1);
        if (b >= 0) gtCounts[b]++;
    });
    detRangesKm.forEach(r => {
        const b = Math.min(Math.floor(r / binSize), N_BINS - 1);
        if (b >= 0) detCounts[b]++;
    });
    clutterRangesKm.forEach(r => {
        const b = Math.min(Math.floor(r / binSize), N_BINS - 1);
        if (b >= 0) clutCounts[b]++;
    });

    const binCenters = Array.from({ length: N_BINS }, (_, i) => ((i + 0.5) * binSize).toFixed(2));
    const pd = Array.from({ length: N_BINS }, (_, i) =>
        gtCounts[i] > 0 ? Math.min(detCounts[i] / gtCounts[i], 1.0) : null
    );

    Plotly.newPlot('eval-chart-det-range', [
        {
            x: binCenters, y: detCounts,
            type: 'bar', name: '✓ Target Detections',
            marker: { color: 'rgba(0,255,100,0.35)', line: { color: '#00ff64', width: 0.5 } },
            yaxis: 'y2',
        },
        {
            x: binCenters, y: clutCounts,
            type: 'bar', name: '✗ False Alarms',
            marker: { color: 'rgba(255,50,50,0.35)', line: { color: '#ff3232', width: 0.5 } },
            yaxis: 'y2',
        },
        {
            x: binCenters, y: pd,
            type: 'scatter', mode: 'lines+markers', name: 'P(D)',
            line: { color: '#ff0066', width: 4, shape: 'spline' },
            marker: { size: 8, color: '#ff0066', symbol: 'diamond', line: { color: '#fff', width: 1 } },
            connectgaps: false,
            hovertemplate: 'Range: %{x} km<br>P(D): %{y:.2%}<extra></extra>',
        },
    ], {
        ...darkLayout,
        barmode: 'stack',
        title: { text: 'Detection Probability vs. Range', font: { size: 10, color: '#e94560' } },
        xaxis: { gridcolor: '#333', title: { text: 'Range (km)', font: { size: 9 } } },
        yaxis: {
            gridcolor: '#333',
            title: { text: 'P(D)', font: { size: 9 } },
            range: [0, 1.1], side: 'left',
        },
        yaxis2: {
            overlaying: 'y', side: 'right',
            title: { text: 'Count', font: { size: 9 } },
            showgrid: false, color: '#aaa',
        },
    }, cfg);
}

function parseStdoutMetrics(stdout) {
    const m = {};
    if (!stdout) return m;
    for (const line of stdout.split('\n')) {
        const t = line.trim();
        const ci = t.indexOf(':');
        if (ci < 0) continue;
        const key = t.substring(0, ci).trim();
        const val = t.substring(ci + 1).trim();
        // Keep raw string (includes units like "m", "%", "s")
        m[key] = val;
    }
    return m;
}

function groupBy(arr, key) {
    return arr.reduce((groups, item) => {
        const val = item[key];
        if (!groups[val]) groups[val] = [];
        groups[val].push(item);
        return groups;
    }, {});
}

// ========================================
// Save / Load Scenario
// ========================================
// ========================================
// Auto-save / Restore (localStorage)
// ========================================
const STORAGE_KEY = 'fasttracker_last_state';

function saveStateToStorage() {
    try {
        const state = {
            missile_type: document.getElementById('missile-type').value,
            launch: launchPoint ? { lat: launchPoint.lat, lon: launchPoint.lon } : null,
            target: targetPoint ? { lat: targetPoint.lat, lon: targetPoint.lon } : null,
            sensor: sensorPoint ? { lat: sensorPoint.lat, lon: sensorPoint.lon } : null,
            missile: {
                boost_duration: document.getElementById('boost-duration').value,
                boost_acceleration: document.getElementById('boost-accel').value,
                launch_angle: document.getElementById('launch-angle').value,
                time_step: document.getElementById('time-step').value,
            },
            hgv: {
                cruise_altitude: document.getElementById('cruise-altitude').value,
                glide_ratio: document.getElementById('glide-ratio').value,
                terminal_dive_range: document.getElementById('terminal-dive-range').value,
                bank_angle_max: document.getElementById('bank-angle-max').value,
                num_skips: document.getElementById('num-skips').value,
            },
            physics: {
                initial_mass: document.getElementById('initial-mass').value,
                fuel_fraction: document.getElementById('fuel-fraction').value,
                specific_impulse: document.getElementById('specific-impulse').value,
                drag_coefficient: document.getElementById('drag-coefficient').value,
                cross_section: document.getElementById('cross-section').value,
                auto_adjust: document.getElementById('auto-adjust').checked,
                enable_separation: document.getElementById('enable-separation').checked,
                warhead_mass_frac: document.getElementById('warhead-mass-frac').value,
                cluster_count: document.getElementById('cluster-count').value,
                cluster_spread: document.getElementById('cluster-spread').value,
                launch_time_spread: document.getElementById('launch-time-spread').value,
                lock_angle: document.getElementById('lock-angle').checked,
                lock_isp: document.getElementById('lock-isp').checked,
                lock_fuel: document.getElementById('lock-fuel').checked,
            },
            radar: {
                min_range: document.getElementById('radar-min-range').value,
                max_range: document.getElementById('radar-max-range').value,
                auto_max_range: document.getElementById('auto-max-range').checked,
                fov: document.getElementById('azimuth-coverage').value,
                pfa: document.getElementById('pfa').value,
                pd_ref: document.getElementById('pd-ref').value,
                pd_ref_range_km: document.getElementById('pd-ref-range').value,
                range_noise: document.getElementById('range-noise').value,
                azimuth_noise: document.getElementById('azimuth-noise').value,
                elevation_noise: document.getElementById('elevation-noise').value,
                doppler_noise: document.getElementById('doppler-noise').value,
                beam_width: document.getElementById('beam-width').value,
                num_beams: document.getElementById('num-beams').value,
                min_search_beams: document.getElementById('min-search-beams').value,
                track_priority: document.getElementById('track-priority').value,
                search_sector: document.getElementById('search-sector').value,
                search_center: document.getElementById('search-center').value,
                auto_search_sector: document.getElementById('auto-search-sector').checked,
                antenna_bearing: document.getElementById('antenna-bearing').value,
                auto_antenna_bearing: document.getElementById('auto-antenna-bearing').checked,
                search_elevation: document.getElementById('search-elevation').value,
                search_min_range: document.getElementById('search-min-range').value,
                search_max_range: document.getElementById('search-max-range').value,
                track_range_width: document.getElementById('track-range-width').value,
            },
            tracker: {
                gate_threshold: document.getElementById('gate-threshold').value,
                confirm_hits: document.getElementById('confirm-hits').value,
                delete_misses: document.getElementById('delete-misses').value,
                min_snr: document.getElementById('min-snr').value,
                process_pos_noise: document.getElementById('process-pos-noise').value,
                process_vel_noise: document.getElementById('process-vel-noise').value,
                process_acc_noise: document.getElementById('process-acc-noise').value,
                num_runs: document.getElementById('num-runs').value,
                seed: document.getElementById('random-seed').value,
            },
            target_max_altitude: document.getElementById('target-max-altitude').value,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) { /* ignore quota errors */ }
}

function restoreStateFromStorage() {
    try {
        const json = localStorage.getItem(STORAGE_KEY);
        if (!json) return;
        const s = JSON.parse(json);

        // Migrate old parameter values to optimized defaults
        if (s.tracker) {
            // False track suppression (2026-02-20 v3)
            if (s.tracker.confirm_hits === '10' || s.tracker.confirm_hits === '5' ||
                s.tracker.confirm_hits === '3' || s.tracker.confirm_hits === '2') {
                s.tracker.confirm_hits = '4';
            }
            if (s.tracker.delete_misses === '100' || s.tracker.delete_misses === '20' ||
                s.tracker.delete_misses === '50' || s.tracker.delete_misses === '80') {
                s.tracker.delete_misses = '35';
            }
            if (s.tracker.gate_threshold === '1500' || s.tracker.gate_threshold === '2500' ||
                s.tracker.gate_threshold === '3000' || s.tracker.gate_threshold === '3500' ||
                s.tracker.gate_threshold === '4500') {
                s.tracker.gate_threshold = '2200';
            }
            if (s.tracker.min_snr === '0' || s.tracker.min_snr === '-5') s.tracker.min_snr = '10';
            if (s.tracker.process_pos_noise === '160' || s.tracker.process_pos_noise === '250') {
                s.tracker.process_pos_noise = '300';
            }
            if (s.tracker.process_vel_noise === '65' || s.tracker.process_vel_noise === '100') {
                s.tracker.process_vel_noise = '150';
            }
            if (s.tracker.process_acc_noise === '160' || s.tracker.process_acc_noise === '250') {
                s.tracker.process_acc_noise = '300';
            }
            // Ensure num_runs is set to 10 for stability
            if (!s.tracker.num_runs || s.tracker.num_runs === '1') {
                s.tracker.num_runs = '10';
            }
        }

        // Map points
        if (s.launch) setLaunchPoint(s.launch.lat, s.launch.lon);
        if (s.target) setTargetPoint(s.target.lat, s.target.lon);

        // Missile type
        if (s.missile_type) {
            document.getElementById('missile-type').value = s.missile_type;
            onMissileTypeChange();
        }

        // Missile
        if (s.missile) {
            if (s.missile.boost_duration != null) document.getElementById('boost-duration').value = s.missile.boost_duration;
            if (s.missile.boost_acceleration != null) document.getElementById('boost-accel').value = s.missile.boost_acceleration;
            if (s.missile.launch_angle != null) document.getElementById('launch-angle').value = s.missile.launch_angle;
            if (s.missile.time_step != null) document.getElementById('time-step').value = s.missile.time_step;
        }

        // HGV
        if (s.hgv) {
            if (s.hgv.cruise_altitude != null) document.getElementById('cruise-altitude').value = s.hgv.cruise_altitude;
            if (s.hgv.glide_ratio != null) document.getElementById('glide-ratio').value = s.hgv.glide_ratio;
            if (s.hgv.terminal_dive_range != null) document.getElementById('terminal-dive-range').value = s.hgv.terminal_dive_range;
            if (s.hgv.bank_angle_max != null) document.getElementById('bank-angle-max').value = s.hgv.bank_angle_max;
            if (s.hgv.num_skips != null) document.getElementById('num-skips').value = s.hgv.num_skips;
        }

        // Physics
        if (s.physics) {
            if (s.physics.initial_mass != null) document.getElementById('initial-mass').value = s.physics.initial_mass;
            if (s.physics.fuel_fraction != null) document.getElementById('fuel-fraction').value = s.physics.fuel_fraction;
            if (s.physics.specific_impulse != null) document.getElementById('specific-impulse').value = s.physics.specific_impulse;
            if (s.physics.drag_coefficient != null) document.getElementById('drag-coefficient').value = s.physics.drag_coefficient;
            if (s.physics.cross_section != null) document.getElementById('cross-section').value = s.physics.cross_section;
            if (s.physics.auto_adjust != null) document.getElementById('auto-adjust').checked = s.physics.auto_adjust;
            if (s.physics.enable_separation != null) {
                document.getElementById('enable-separation').checked = s.physics.enable_separation;
                toggleSeparationParams();
            }
            if (s.physics.warhead_mass_frac != null) document.getElementById('warhead-mass-frac').value = s.physics.warhead_mass_frac;
            if (s.physics.cluster_count != null) document.getElementById('cluster-count').value = s.physics.cluster_count;
            if (s.physics.cluster_spread != null) document.getElementById('cluster-spread').value = s.physics.cluster_spread;
            if (s.physics.launch_time_spread != null) document.getElementById('launch-time-spread').value = s.physics.launch_time_spread;
            if (s.physics.lock_angle != null) document.getElementById('lock-angle').checked = s.physics.lock_angle;
            if (s.physics.lock_isp != null) document.getElementById('lock-isp').checked = s.physics.lock_isp;
            if (s.physics.lock_fuel != null) document.getElementById('lock-fuel').checked = s.physics.lock_fuel;
        }

        // Radar
        if (s.radar) {
            if (s.radar.min_range != null) document.getElementById('radar-min-range').value = s.radar.min_range;
            if (s.radar.max_range != null) document.getElementById('radar-max-range').value = s.radar.max_range;
            if (s.radar.fov != null) document.getElementById('azimuth-coverage').value = s.radar.fov;
            if (s.radar.pfa != null) document.getElementById('pfa').value = s.radar.pfa;
            if (s.radar.pd_ref != null) document.getElementById('pd-ref').value = s.radar.pd_ref;
            if (s.radar.pd_ref_range_km != null) document.getElementById('pd-ref-range').value = s.radar.pd_ref_range_km;
            if (s.radar.range_noise != null) document.getElementById('range-noise').value = s.radar.range_noise;
            if (s.radar.azimuth_noise != null) document.getElementById('azimuth-noise').value = s.radar.azimuth_noise;
            if (s.radar.elevation_noise != null) document.getElementById('elevation-noise').value = s.radar.elevation_noise;
            if (s.radar.doppler_noise != null) document.getElementById('doppler-noise').value = s.radar.doppler_noise;
            if (s.radar.beam_width != null) document.getElementById('beam-width').value = s.radar.beam_width;
            if (s.radar.num_beams != null) document.getElementById('num-beams').value = s.radar.num_beams;
            if (s.radar.min_search_beams != null) document.getElementById('min-search-beams').value = s.radar.min_search_beams;
            if (s.radar.track_priority != null) document.getElementById('track-priority').value = s.radar.track_priority;
            if (s.radar.search_sector != null) document.getElementById('search-sector').value = s.radar.search_sector;
            if (s.radar.search_center != null) document.getElementById('search-center').value = s.radar.search_center;
            if (s.radar.auto_search_sector != null) {
                document.getElementById('auto-search-sector').checked = s.radar.auto_search_sector;
                onAutoSearchSectorChange();
            }
            if (s.radar.antenna_bearing != null) document.getElementById('antenna-bearing').value = s.radar.antenna_bearing;
            if (s.radar.auto_antenna_bearing != null) {
                document.getElementById('auto-antenna-bearing').checked = s.radar.auto_antenna_bearing;
                onAutoAntennaBearingChange();
            }
            if (s.radar.search_elevation != null) document.getElementById('search-elevation').value = s.radar.search_elevation;
            if (s.radar.search_min_range != null) document.getElementById('search-min-range').value = s.radar.search_min_range;
            if (s.radar.search_max_range != null) document.getElementById('search-max-range').value = s.radar.search_max_range;
            if (s.radar.track_range_width != null) document.getElementById('track-range-width').value = s.radar.track_range_width;
            if (s.radar.auto_max_range != null) {
                document.getElementById('auto-max-range').checked = s.radar.auto_max_range;
                toggleAutoParam(document.getElementById('auto-max-range'), 'radar-max-range');
            }
        }

        // Tracker
        if (s.tracker) {
            if (s.tracker.gate_threshold != null) document.getElementById('gate-threshold').value = s.tracker.gate_threshold;
            if (s.tracker.confirm_hits != null) document.getElementById('confirm-hits').value = s.tracker.confirm_hits;
            if (s.tracker.delete_misses != null) document.getElementById('delete-misses').value = s.tracker.delete_misses;
            if (s.tracker.min_snr != null) document.getElementById('min-snr').value = s.tracker.min_snr;
            if (s.tracker.process_pos_noise != null) document.getElementById('process-pos-noise').value = s.tracker.process_pos_noise;
            if (s.tracker.process_vel_noise != null) document.getElementById('process-vel-noise').value = s.tracker.process_vel_noise;
            if (s.tracker.process_acc_noise != null) document.getElementById('process-acc-noise').value = s.tracker.process_acc_noise;
            if (s.tracker.num_runs != null) document.getElementById('num-runs').value = s.tracker.num_runs;
            if (s.tracker.seed != null) document.getElementById('random-seed').value = s.tracker.seed;
        }

        if (s.target_max_altitude != null) document.getElementById('target-max-altitude').value = s.target_max_altitude;

        // Sensor point (after map points so sensor coverage can draw)
        if (s.sensor) setSensorPoint(s.sensor.lat, s.sensor.lon);

        // Auto: always re-apply after all points are restored
        onAutoAntennaBearingChange();
        onAutoSearchSectorChange();

        updateSensorMarker();
        updateSensorCoverage();

        // Fit map
        if (launchPoint && targetPoint) {
            map.fitBounds([
                [launchPoint.lat, launchPoint.lon],
                [targetPoint.lat, targetPoint.lon],
            ], { padding: [50, 50] });
        }

        updateStatus('Previous state restored');
    } catch (e) { /* ignore parse errors */ }
}

function saveScenario() {
    if (!launchPoint || !targetPoint) {
        alert('Please set both launch and target points before saving.');
        return;
    }

    const scenario = {
        version: 3,
        missile_type: document.getElementById('missile-type').value,
        launch: { lat: launchPoint.lat, lon: launchPoint.lon },
        target: { lat: targetPoint.lat, lon: targetPoint.lon },
        sensor: {
            lat: sensorPoint?.lat ?? null,
            lon: sensorPoint?.lon ?? null,
        },
        missile: {
            boost_duration: parseFloat(document.getElementById('boost-duration').value),
            boost_acceleration: parseFloat(document.getElementById('boost-accel').value),
            launch_angle: parseFloat(document.getElementById('launch-angle').value),
            time_step: parseFloat(document.getElementById('time-step').value),
        },
        hgv: {
            cruise_altitude: parseFloat(document.getElementById('cruise-altitude').value),
            glide_ratio: parseFloat(document.getElementById('glide-ratio').value),
            terminal_dive_range: parseFloat(document.getElementById('terminal-dive-range').value),
            bank_angle_max: parseFloat(document.getElementById('bank-angle-max').value),
            num_skips: parseInt(document.getElementById('num-skips').value) || 0,
        },
        physics: {
            initial_mass: parseFloat(document.getElementById('initial-mass').value),
            fuel_fraction: parseFloat(document.getElementById('fuel-fraction').value),
            specific_impulse: parseFloat(document.getElementById('specific-impulse').value),
            drag_coefficient: parseFloat(document.getElementById('drag-coefficient').value),
            cross_section_area: parseFloat(document.getElementById('cross-section').value),
            auto_adjust: document.getElementById('auto-adjust').checked,
            enable_separation: document.getElementById('enable-separation').checked,
            warhead_mass_frac: parseFloat(document.getElementById('warhead-mass-frac').value),
            cluster_count: parseInt(document.getElementById('cluster-count').value) || 0,
            cluster_spread: parseFloat(document.getElementById('cluster-spread').value),
            launch_time_spread: parseFloat(document.getElementById('launch-time-spread').value),
        },
        radar: {
            min_range_km: parseFloat(document.getElementById('radar-min-range').value),
            max_range_km: parseFloat(document.getElementById('radar-max-range').value),
            auto_max_range: document.getElementById('auto-max-range').checked,
            fov_deg: parseFloat(document.getElementById('azimuth-coverage').value),
            pfa: document.getElementById('pfa').value,
            pd_ref: parseFloat(document.getElementById('pd-ref').value),
            pd_ref_range_km: parseFloat(document.getElementById('pd-ref-range').value),
            range_noise: parseFloat(document.getElementById('range-noise').value),
            azimuth_noise: parseFloat(document.getElementById('azimuth-noise').value),
            elevation_noise: parseFloat(document.getElementById('elevation-noise').value),
            doppler_noise: parseFloat(document.getElementById('doppler-noise').value),
            beam_width_deg: parseFloat(document.getElementById('beam-width').value),
            num_beams: parseInt(document.getElementById('num-beams').value),
            min_search_beams: parseInt(document.getElementById('min-search-beams').value),
            track_priority: document.getElementById('track-priority').value,
            search_sector_deg: parseFloat(document.getElementById('search-sector').value),
            search_center_deg: parseFloat(document.getElementById('search-center').value),
            auto_search_sector: document.getElementById('auto-search-sector').checked,
            antenna_bearing_deg: parseFloat(document.getElementById('antenna-bearing').value),
            auto_antenna_bearing: document.getElementById('auto-antenna-bearing').checked,
            search_elevation_deg: parseFloat(document.getElementById('search-elevation').value),
            search_min_range_km: parseFloat(document.getElementById('search-min-range').value),
            search_max_range_km: parseFloat(document.getElementById('search-max-range').value),
        },
        tracker: {
            gate_threshold: parseFloat(document.getElementById('gate-threshold').value),
            confirm_hits: parseInt(document.getElementById('confirm-hits').value),
            delete_misses: parseInt(document.getElementById('delete-misses').value),
            min_snr: parseFloat(document.getElementById('min-snr').value),
            process_pos_noise: parseFloat(document.getElementById('process-pos-noise').value),
            process_vel_noise: parseFloat(document.getElementById('process-vel-noise').value),
            process_acc_noise: parseFloat(document.getElementById('process-acc-noise').value),
            num_runs: parseInt(document.getElementById('num-runs').value),
            seed: parseInt(document.getElementById('random-seed').value),
        },
    };

    const json = JSON.stringify(scenario, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const now = new Date();
    const ts = now.getFullYear().toString()
        + String(now.getMonth() + 1).padStart(2, '0')
        + String(now.getDate()).padStart(2, '0')
        + '_'
        + String(now.getHours()).padStart(2, '0')
        + String(now.getMinutes()).padStart(2, '0')
        + String(now.getSeconds()).padStart(2, '0');

    const a = document.createElement('a');
    a.href = url;
    a.download = `fasttracker_scenario_${ts}.json`;
    a.click();
    URL.revokeObjectURL(url);

    updateStatus('Scenario saved');
}

function loadScenario(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const scenario = JSON.parse(e.target.result);

            // Restore launch & target
            if (scenario.launch) setLaunchPoint(scenario.launch.lat, scenario.launch.lon);
            if (scenario.target) setTargetPoint(scenario.target.lat, scenario.target.lon);

            // Restore missile type
            if (scenario.missile_type) {
                document.getElementById('missile-type').value = scenario.missile_type;
                onMissileTypeChange();
            }

            // Restore HGV params
            if (scenario.hgv) {
                if (scenario.hgv.cruise_altitude != null) document.getElementById('cruise-altitude').value = scenario.hgv.cruise_altitude;
                if (scenario.hgv.glide_ratio != null) document.getElementById('glide-ratio').value = scenario.hgv.glide_ratio;
                if (scenario.hgv.terminal_dive_range != null) document.getElementById('terminal-dive-range').value = scenario.hgv.terminal_dive_range;
                if (scenario.hgv.bank_angle_max != null) document.getElementById('bank-angle-max').value = scenario.hgv.bank_angle_max;
                if (scenario.hgv.num_skips != null) document.getElementById('num-skips').value = scenario.hgv.num_skips;
            }

            // Restore missile params
            if (scenario.missile) {
                if (scenario.missile.boost_duration != null) document.getElementById('boost-duration').value = scenario.missile.boost_duration;
                if (scenario.missile.boost_acceleration != null) document.getElementById('boost-accel').value = scenario.missile.boost_acceleration;
                if (scenario.missile.launch_angle != null) document.getElementById('launch-angle').value = scenario.missile.launch_angle;
                if (scenario.missile.time_step != null) document.getElementById('time-step').value = scenario.missile.time_step;
            }

            // Restore physics params
            if (scenario.physics) {
                if (scenario.physics.initial_mass != null) document.getElementById('initial-mass').value = scenario.physics.initial_mass;
                if (scenario.physics.fuel_fraction != null) document.getElementById('fuel-fraction').value = scenario.physics.fuel_fraction;
                if (scenario.physics.specific_impulse != null) document.getElementById('specific-impulse').value = scenario.physics.specific_impulse;
                if (scenario.physics.drag_coefficient != null) document.getElementById('drag-coefficient').value = scenario.physics.drag_coefficient;
                if (scenario.physics.cross_section_area != null) document.getElementById('cross-section').value = scenario.physics.cross_section_area;
                if (scenario.physics.auto_adjust != null) document.getElementById('auto-adjust').checked = scenario.physics.auto_adjust;
                if (scenario.physics.enable_separation != null) {
                    document.getElementById('enable-separation').checked = scenario.physics.enable_separation;
                    toggleSeparationParams();
                }
                if (scenario.physics.warhead_mass_frac != null) document.getElementById('warhead-mass-frac').value = scenario.physics.warhead_mass_frac;
                if (scenario.physics.cluster_count != null) document.getElementById('cluster-count').value = scenario.physics.cluster_count;
                if (scenario.physics.cluster_spread != null) document.getElementById('cluster-spread').value = scenario.physics.cluster_spread;
                if (scenario.physics.launch_time_spread != null) document.getElementById('launch-time-spread').value = scenario.physics.launch_time_spread;
            }

            // Restore tracker params
            if (scenario.tracker) {
                if (scenario.tracker.gate_threshold != null) document.getElementById('gate-threshold').value = scenario.tracker.gate_threshold;
                if (scenario.tracker.confirm_hits != null) document.getElementById('confirm-hits').value = scenario.tracker.confirm_hits;
                if (scenario.tracker.delete_misses != null) document.getElementById('delete-misses').value = scenario.tracker.delete_misses;
                if (scenario.tracker.min_snr != null) document.getElementById('min-snr').value = scenario.tracker.min_snr;
                if (scenario.tracker.process_pos_noise != null) document.getElementById('process-pos-noise').value = scenario.tracker.process_pos_noise;
                if (scenario.tracker.process_vel_noise != null) document.getElementById('process-vel-noise').value = scenario.tracker.process_vel_noise;
                if (scenario.tracker.process_acc_noise != null) document.getElementById('process-acc-noise').value = scenario.tracker.process_acc_noise;
                if (scenario.tracker.num_runs != null) document.getElementById('num-runs').value = scenario.tracker.num_runs;
                if (scenario.tracker.seed != null) document.getElementById('random-seed').value = scenario.tracker.seed;
            }

            // Restore sensor params
            if (scenario.radar) {
                if (scenario.radar.min_range_km != null) document.getElementById('radar-min-range').value = scenario.radar.min_range_km;
                if (scenario.radar.max_range_km != null) document.getElementById('radar-max-range').value = scenario.radar.max_range_km;
                if (scenario.radar.fov_deg != null) document.getElementById('azimuth-coverage').value = scenario.radar.fov_deg;
                if (scenario.radar.pfa != null) document.getElementById('pfa').value = scenario.radar.pfa;
                // 旧形式の後方互換
                if (scenario.radar.clutter_per_scan != null && scenario.radar.pfa == null) document.getElementById('pfa').value = scenario.radar.clutter_per_scan;
                if (scenario.radar.pd_ref != null) document.getElementById('pd-ref').value = scenario.radar.pd_ref;
                if (scenario.radar.pd_ref_range_km != null) document.getElementById('pd-ref-range').value = scenario.radar.pd_ref_range_km;
                if (scenario.radar.range_noise != null) document.getElementById('range-noise').value = scenario.radar.range_noise;
                if (scenario.radar.azimuth_noise != null) document.getElementById('azimuth-noise').value = scenario.radar.azimuth_noise;
                if (scenario.radar.elevation_noise != null) document.getElementById('elevation-noise').value = scenario.radar.elevation_noise;
                if (scenario.radar.doppler_noise != null) document.getElementById('doppler-noise').value = scenario.radar.doppler_noise;
                // Auto checkboxes
                const autoMaxRange = scenario.radar.auto_max_range !== false;
                document.getElementById('auto-max-range').checked = autoMaxRange;
                toggleAutoParam(document.getElementById('auto-max-range'), 'radar-max-range');
                // Beam steering
                if (scenario.radar.beam_width_deg != null) document.getElementById('beam-width').value = scenario.radar.beam_width_deg;
                if (scenario.radar.num_beams != null) document.getElementById('num-beams').value = scenario.radar.num_beams;
                if (scenario.radar.min_search_beams != null) document.getElementById('min-search-beams').value = scenario.radar.min_search_beams;
                if (scenario.radar.track_priority != null) document.getElementById('track-priority').value = scenario.radar.track_priority;
                if (scenario.radar.search_sector_deg != null) document.getElementById('search-sector').value = scenario.radar.search_sector_deg;
                if (scenario.radar.search_center_deg != null) document.getElementById('search-center').value = scenario.radar.search_center_deg;
                if (scenario.radar.auto_search_sector != null) {
                    document.getElementById('auto-search-sector').checked = scenario.radar.auto_search_sector;
                    onAutoSearchSectorChange();
                }
                if (scenario.radar.antenna_bearing_deg != null) document.getElementById('antenna-bearing').value = scenario.radar.antenna_bearing_deg;
                if (scenario.radar.auto_antenna_bearing != null) {
                    document.getElementById('auto-antenna-bearing').checked = scenario.radar.auto_antenna_bearing;
                    onAutoAntennaBearingChange();
                }
                if (scenario.radar.search_elevation_deg != null) document.getElementById('search-elevation').value = scenario.radar.search_elevation_deg;
                if (scenario.radar.search_min_range_km != null) document.getElementById('search-min-range').value = scenario.radar.search_min_range_km;
                if (scenario.radar.search_max_range_km != null) document.getElementById('search-max-range').value = scenario.radar.search_max_range_km;
            }

            if (scenario.sensor && scenario.sensor.lat != null && scenario.sensor.lon != null) {
                setSensorPoint(scenario.sensor.lat, scenario.sensor.lon);
            }

            updateSensorMarker();
            updateSensorCoverage();

            // Fit map to show both points
            if (launchPoint && targetPoint) {
                map.fitBounds([
                    [launchPoint.lat, launchPoint.lon],
                    [targetPoint.lat, targetPoint.lon],
                ], { padding: [50, 50] });
            }

            // Auto-generate trajectory
            generateTrajectory();

            updateStatus('Scenario loaded: ' + file.name);
        } catch (err) {
            alert('Failed to load scenario: ' + err.message);
        }
    };
    reader.readAsText(file);

    // Reset input so the same file can be loaded again
    event.target.value = '';
}

// ========================================
// UI Helpers
// ========================================
function updateSummary(summary) {
    const container = document.getElementById('eval-results');
    container.innerHTML = `
        <div class="eval-item"><span class="label">Range:</span> <span class="value">${summary.range_km} km</span></div>
        <div class="eval-item"><span class="label">Duration:</span> <span class="value">${summary.flight_duration} s</span></div>
        <div class="eval-item"><span class="label">Max Speed:</span> <span class="value">${summary.max_speed.toFixed(0)} m/s</span></div>
        <div class="eval-item"><span class="label">Max Altitude:</span> <span class="value">${(summary.max_altitude/1000).toFixed(1)} km</span></div>
        <div class="eval-item"><span class="label">Data Points:</span> <span class="value">${summary.num_steps}</span></div>
    `;
}

function updateStatus(text) {
    document.getElementById('status-text').textContent = text;
}

function showLoading(text) {
    document.getElementById('loading-text').textContent = text;
    document.getElementById('loading-progress-container').style.display = 'none';
    document.getElementById('btn-cancel-tracker').style.display = 'none';
    document.getElementById('loading').classList.add('active');
}

function showTrackerLoading(text) {
    document.getElementById('loading-text').textContent = text;
    document.getElementById('loading-progress-container').style.display = 'block';
    document.getElementById('loading-progress-bar').style.width = '0%';
    document.getElementById('loading-progress-pct').textContent = '0%';
    document.getElementById('loading-progress-detail').textContent = '';
    document.getElementById('btn-cancel-tracker').style.display = 'inline-block';
    document.getElementById('loading').classList.add('active');
}

function updateTrackerProgress(pct, detail) {
    const p = Math.max(0, Math.min(100, pct || 0));
    document.getElementById('loading-progress-bar').style.width = p.toFixed(1) + '%';
    document.getElementById('loading-progress-pct').textContent = p.toFixed(0) + '%';
    if (detail) {
        document.getElementById('loading-progress-detail').textContent = detail;
    }
}

function hideLoading() {
    document.getElementById('loading').classList.remove('active');
    document.getElementById('loading-progress-container').style.display = 'none';
    document.getElementById('btn-cancel-tracker').style.display = 'none';
}

function clearAll() {
    if (launchMarker) map.removeLayer(launchMarker);
    if (targetMarker) map.removeLayer(targetMarker);
    if (sensorMarker) map.removeLayer(sensorMarker);
    if (sensorCoverageCircle) map.removeLayer(sensorCoverageCircle);
    if (sensorFovPolygon) map.removeLayer(sensorFovPolygon);
    if (searchSectorPolygon) map.removeLayer(searchSectorPolygon);
    if (trajectoryLine) map.removeLayer(trajectoryLine);
    launchPoint = null;
    targetPoint = null;
    sensorPoint = null;
    sensorMarker = null;
    sensorCoverageCircle = null;
    sensorFovPolygon = null;
    searchSectorPolygon = null;
    currentTrajectory = null;
    document.getElementById('launch-coord').textContent = 'Not set';
    document.getElementById('target-coord').textContent = 'Not set';
    document.getElementById('sensor-coord').textContent = 'Not set';
    document.getElementById('range-display').textContent = '-';
    document.getElementById('btn-run-tracker').disabled = true;
    // Reset auto checkboxes and resolved hints
    ['auto-max-range'].forEach(id => {
        document.getElementById(id).checked = true;
    });
    [['auto-max-range','radar-max-range']].forEach(([cbId, inputId]) => {
        toggleAutoParam(document.getElementById(cbId), inputId);
    });
    ['resolved-max-range', 'resolved-snr-ref'].forEach(id => {
        document.getElementById(id).textContent = '';
    });
    document.getElementById('eval-results').innerHTML = '<div class="eval-item"><span class="label">Status:</span> <span class="value">Waiting</span></div>';
    Plotly.purge('plot3d-trajectory');
    Plotly.purge('plot3d-tracking');
    Plotly.purge('plot-timeline');
    document.getElementById('eval-tab-content').innerHTML = '<div class="eval-placeholder">Run Tracker to see evaluation metrics</div>';
    switchVizTab('trajectory');

    // Remove trajectory lines from map
    map.eachLayer(layer => {
        if (layer instanceof L.Polyline && !(layer instanceof L.Rectangle)) {
            map.removeLayer(layer);
        }
    });

    updateStatus('Cleared - Click on map to set launch/target points');
}

// Initial 3D placeholder
Plotly.newPlot('plot3d-trajectory', [], {
    scene: {
        xaxis: { title: 'X (km)', backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa' },
        yaxis: { title: 'Y (km)', backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa' },
        zaxis: { title: 'Altitude (km)', backgroundcolor: '#16213e', gridcolor: '#333', color: '#aaa' },
        aspectmode: 'cube',  // 1:1:1 aspect ratio for true spatial representation
    },
    paper_bgcolor: '#16213e',
    plot_bgcolor: '#16213e',
    font: { color: '#e0e0e0' },
    margin: { l: 0, r: 0, t: 30, b: 0 },
    title: { text: 'Generate a trajectory to visualize', font: { size: 14, color: '#666' } },
    annotations: [{
        text: 'Set launch & target points on the map,<br>then click "Generate Trajectory"',
        showarrow: false,
        font: { size: 16, color: '#555' },
        xref: 'paper', yref: 'paper',
        x: 0.5, y: 0.5,
    }],
}, { responsive: true });

// Handle window resize
window.addEventListener('resize', () => {
    map.invalidateSize();
    if (activeVizTab === 'trajectory' || activeVizTab === 'tracking') {
        const el = document.getElementById('plot3d-' + activeVizTab);
        if (el && el.data) Plotly.Plots.resize(el);
    } else if (activeVizTab === 'evaluation') {
        ['eval-chart-pos', 'eval-chart-ospa', 'eval-chart-tracks', 'eval-chart-detect'].forEach(id => {
            const el = document.getElementById(id);
            if (el && el.data) Plotly.Plots.resize(el);
        });
    }
});
</script>
</body>
</html>
